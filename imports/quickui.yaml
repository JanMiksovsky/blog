2012-01-30.html: |
  ---
  title: "QuickUI 0.8.8 released"
  date: 2012-01-30
  slug: quickui-0-8-8-released
  originalUrl: http://blog.quickui.org/2012/01/30/quickui-0-8-8-released/
  ---
  A small breaking change in this release:
  <ul>
    <li>The "name" attribute on top-level &lt;Control&gt; tags has been changed to "className". Before:</li>
  </ul>
  <blockquote>&lt;Control name="MyControl"&gt;</blockquote>
  Now:
  <blockquote>&lt;Control className="MyControl"&gt;</blockquote>
  This change allows some consistency with the run-time function className(), and also reduces the chances for confusion if a Control class itself wants to define a "name" property.

  This is a breaking change, so markup users will need to download/build the latest qb tool, and force a rebuild of their project.

2012-02-01.html: |
  ---
  title: "Updated tutorial for JavaScript-only QuickUI development"
  date: 2012-02-01
  slug: updated-tutorial-for-javascript-only-quickui-development
  originalUrl: http://blog.quickui.org/2012/02/01/updated-tutorial-for-javascript-only-quickui-development/
  ---
  The new <a href="http://quickui.org/tutorial/">QuickUI Tutorial</a> shows you how to use QuickUI in plain JavaScript, without the need for a proprietary markup language or client-side compiler.

  The tutorial is divided into two sections: the first shows how you can use QuickUI controls in your site (e.g., one mostly constructed via some other tool), and the second shows how to create your own QuickUI controls. The tutorial is built around small interactive coding exercises, each of which demonstrates some aspect of the framework. Due to current limitations of the code editor, the tutorial is not functional in IE8 and Safari. It works fine in Chrome, Firefox, and IE9.

  The existing markup tutorial has been moved to a new <a href="http://quickui.org/markup/">Markup</a> section that also now hosts the Downloads page for the client-side compiler. This reorganization helps emphasize the fact that the use of QuickUI markup is an optional, somewhat advanced mode of use; markup is no longer required to use or create QuickUI controls.

  This tutorial represents the first of several forthcoming steps to make QuickUI more appealing to a wider JavaScript audience.

2012-02-14.html: |
  ---
  title: "Catalog control documentation now includes description of control properties and other methods"
  date: 2012-02-14
  slug: catalog-control-documentation-now-includes-description-of-control-properties-and-other-methods
  originalUrl: http://blog.quickui.org/2012/02/14/catalog-control-documentation-now-includes-description-of-control-properties-and-other-methods/
  ---
  <p>The documentation for the QuickUI Catalog, which now contains 60+ controls, has been updated to include documentation of each class' properties and methods.</p>
  <p>Previously, the only way to see how to use a control was to read the original control source code on GitHub. Now the descriptions for a class' members are extracted from the source, and then used to populate the documentation page for that class. For example, the <a href="https://github.com/JanMiksovsky/quickui-catalog/blob/master/quickui.catalog/ListBox.qui">ListBox source</a> is parsed to create the <a href="http://quickui.org/catalog/ListBox/">ListBox</a> documentation page.</p>

2012-03-17.html: |
  ---
  title: "QuickUI 0.8.9 released"
  date: 2012-03-17
  slug: quickui-0-8-9-released
  originalUrl: http://blog.quickui.org/2012/03/16/quickui-0-8-9-released/
  ---
  <p>A minor update.</p><ul><li>To facilitate controls that want to perform their own layout, controls can bind to a new <a href="http://quickui.org/docs/control-events.html#layout">layout</a> event. Catalog controls like HorizontalPanels, VerticalPanels, PanelWithOverlfow, and PersistentPanel use this to recalculate the layout of their contents in response to a change in window size.</li><li>A companion event called <a href="http://quickui.org/docs/control-events.html#sizeChanged">sizeChanged</a> can be triggered by a control that wants to cooperatively let its parents know about a change in the control's size.</li><li>A helper Control method called <a href="http://quickui.org/docs/control-prototype-methods.html#checkForSizeChange">checkForSizeChange()</a> can be called if a control has updated its contents and there's the possibility that its size has changed. The helper records the control's last known size and, if the size has indeed change, raises the aforementioned sizeChanged event.</li></ul>

2012-04-16.html: |
  ---
  title: "vision for coevolving QuickUI and the emerging Web Components standard"
  date: 2012-04-16
  slug: a-vision-for-coevolving-quickui-and-the-emerging-web-components-standard
  originalUrl: http://blog.quickui.org/2012/04/16/a-vision-for-coevolving-quickui-and-the-emerging-web-components-standard/
  ---
  This post is the first in a series looking at the relationship between QuickUI and Web Components. This post will kick things off by laying out some basic points of a vision for how these two technologies might co-evolve.

  The Web Components effort spearheaded by Google is a vital effort towards promoting component-based user interface design for web-based apps. Componentized user interfaces may <a href="http://miksovsky.blogs.com/flowstate/2012/03/snapping-together-a-skyscraper.html">radically transform the web industry</a>. It will take some time for the spec to be finished and agreed upon, and then still more time for the technology to make its way into users’ hands. It is hoped that QuickUI can serve as a bridge to the world of Web Components, act as a reference point for work on the emerging spec, and provide services and component libraries that speed the creation of Web Component-based apps.
  <h1>QuickUI and Web Components have the same goal</h1>
  Both frameworks address the same fundamental objective: let web designers and developers create better applications faster through the creation and use of modular, reusable, and extensible user interface elements. QuickUI calls such elements “controls” and the Web Components spec calls them “components”, but in this context the terms are essentially interchangeable.

  There are obviously differences in approach. QuickUI is built on JavaScript and jQuery, while Web Components is native code and browser- and library-agnostic. The Web Components framework, by virtue of being part of the browser, can do many things which a JavaScript library like QuickUI cannot. There are some obvious performance benefits to doing things in native code. It’s also possible for the browser to enforce a high degree of component isolation by preventing a Web Component’s host from knowing what’s going on inside the component. Such isolation is crucial for a component platform, because it leads to a proper <a href="http://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns</a>. A component author can make many modifications to the inner workings of a component without fear that hosts of that component are inappropriately depending on a particular implementation. QuickUI can only maintain such separation of concerns by convention and by proffering services that make it easier for developers to use controls in a modular way than not.

  Despite their differences, fundamentally these two web user interface frameworks are more compatible than not. This opens up the possibilities which follow.
  <h2>QuickUI and Web Components should be interoperable</h2>
  Based on the current Web Components spec, in theory it should be straightforward for a QuickUI control to host a Web Component, and vice versa. That can provide a degree of future-proof resiliency to a team that wants to build with QuickUI today. But it should be possible to do better than that…
  <h1>QuickUI itself will someday be built on top of the Web Components foundation</h1>
  Given the performance and modularity benefits of Web Components, and the reasonably close alignment of goals, it appears that it should be possible to eventually have QuickUI controls <em>be </em>Web Components.

  Currently, the lowest levels of the quickui.js runtime provides services such as creating control subclasses and instantiating controls. These low-level services would be provided by a Web Components-enabled browser instead. The QuickUI runtime could potentially detect whether the user’s browser supports Web Components and, if so, create controls as Web Components wrapped by jQuery. On legacy browsers (all today’s released browser versions, going back to IE 8), the QuickUI runtime would continue to create controls as regular DOM elements wrapped by jQuery.
  <h1>QuickUI can provide useful features beyond those which have been standardized</h1>
  Standards, by their nature, advance slowly. Even once QuickUI is built on top of Web Components, QuickUI can continue to evolve at a faster pace to meet the needs of web designers and developers. QuickUI can be the “running code” in the maxim that Internet standards evolve from <a href="http://en.wikipedia.org/wiki/Rough_consensus">Rough consensus, running code</a>.

  QuickUI is also designed explicitly for jQuery developers, whereas the Web Components spec must be library-agnostic. In the same way that jQuery developers currently find it much easier to write an interactive UI in jQuery than by doing direct DOM manipulation, they will also find creating controls (components) easier in QuickUI than using only the low-level services offered by the browser. For example, <a href="http://quickui.org/tutorial/inherit-from-jQuery.html">a QuickUI control is already a jQuery instance</a>, so a developer can immediately and directly manipulate a control using all the facilities in jQuery. As another example, QuickUI’s services for creating properties generate jQuery-style getter/setter functions which are automatically chainable, and can be applied to a collection of elements in a single call.
  <h1>QuickUI may serve as a reference for work on Web Components</h1>
  As a 4+ year-old web user interface framework, there’s already a considerable degree of hard-earned knowledge baked into the QuickUI framework. These lessons can be considered as the various parties working on Web Components flesh out the details of that spec. It’s in this role of QuickUI as a reference point that some of the important lessons from QuickUI will be covered in future posts on this blog.
  <h1>QuickUI lets teams create componentized web user interfaces today</h1>
  Many of the benefits of building a user interface with components can be achieved by a team using QuickUI today. As summarized on the <a href="http://quickui.org">QuickUI home page</a>, those benefits include the abilities to:
  <ul>
    <li>Better organize and maintain UI code.</li>
    <li>Use custom controls to provide optimized user interactions or a particular visual aesthetic.</li>
    <li>To begin developing, in the course of one project, a library of reusable UI that can accelerate a team’s future projects.</li>
    <li>Share common UI solutions across teams and organizations so those solutions don’t need to be created from scratch each time.</li>
  </ul>
  <h1>Investment in QuickUI apps today can be preserved when Web Components arrive</h1>
  This is a <em>vision</em>, not a legal commitment. The Web Components spec is still in flux and evolving entirely outside the control of anyone working on QuickUI, so it’s impossible to promise how things will work in the future. Still, it’s plausible that a team could begin creating a web user interface in QuickUI today, and as Web Component-enabled browsers arrive and gain use, the team could automatically (or, at least, easily) transition to that better foundation to improve the performance and reliability of their apps.
  <h1>The QuickUI Catalog will evolve into the web’s best open library of reusable user interface components</h1>
  To an extent, the <a href="http://quickui.org/catalog">QuickUI Catalog</a> of common, ready-to-use controls is somewhat independent of the underlying QuickUI foundation. At the most abstract level, these are user interface patterns that can be found in many applications on many platforms. Even if obstacles prevent QuickUI controls from being built as Web Components, the existing JavaScript code base for the Catalog would give one a huge headstart in creating an equivalent library of Web Components. And if the vision outlined here comes to pass, the Catalog’s collection of components — and user interfaces built with them — should be able to transition smoothly to a Web Components foundation.
  <h2></h2>
  <h1>Next steps: investigation of framework differences</h1>
  While the above points lay out a vision for the coevolution of QuickUI and Web Components, many details remain which must be investigated before such a vision can come to pass. While the goals of the two frameworks are generally aligned, the design principles underlying the two have significant differences. For example, QuickUI’s <a href="http://quickui.org/docs/principles.html">core design principles</a> seem to place greater emphasis on extensibility — creating a new control class by extending an existing class — than does the current Web Components spec. Such differences could lead to irreconcilable incompatibilities, which would represent lost opportunity.

  The hope is that any issues can be teased out of the Web Components spec early enough and either worked around or submitted for consideration so that they may hopefully be addressed. Some key issues warranting further investigation are:
  <ol>
    <li>A significant fraction of QuickUI controls override their base class’ content() property setter function in order to perform work when a host sets a control’s content. This is done for a variety of reasons: to partially fill in a component’s DOM tree (a sort of user interface <a href="http://en.wikipedia.org/wiki/Currying">currying</a>); to transform content before displaying it; to recalculate layout; or to perform other operations dependent upon the content. This is not currently supported in the Web Components spec. An analysis of the QuickUI Catalog controls on this topic is underway to produce a set of common use cases.</li>
    <li>A QuickUI subclass maintains an is-a relationship with its base class. The &lt;shadow&gt; element in the Web Components spec may lead to subclasses that effectively maintain more of a has-a relationship with their parent class. It’s not immediately clear, for example, how one could define a base class and a subclass that meet all these conditions: a) both use the same root element (e.g., &lt;button&gt;), b) both are independently instantiable, c) the subclass can host base class elements (e.g., via &lt;shadow&gt;), and d) the subclass is a JavaScript instanceof (is-a) of the base class. These conditions often arise when extending an existing control class, and QuickUI control classes can meet all of them.</li>
    <li>The Web Components proposal minimizes the impact on the HTML language itself, but one repercussion of this appears to be that component classes can’t define custom properties that can be set through markup. As currently understood, the spec calls for hosts to pass values to components exclusively through a single content tree. The component class must then prise apart this content through a “select=” attribute so that it can incorporate content subelements into different parts of the component.This is roughly analogous to the way command-line apps must parse their text arguments, with both the flexibility and the potential for great inconsistency that go with that. In this context, such flexibility may create significant complications for the creation and maintenance of subclasses, as varying levels of the class hierarchy impose different demands on the content. Overall, this doesn’t feel as specific or clean as the compound property syntax in a language like XAML (or <a href="http://quickui.org/markup/">QuickUI Markup</a>), in which a control class can define custom properties that may be set as string attributes, through nested subelements, or through property setter functions.</li>
  </ol>
  As these issues are investigated more deeply, the results of those investigations will be posted here.

2012-04-27.html: |
  ---
  title: "How QuickUI controls use code to specialize the handling of their content (in ways that might not be supported by Web Components"
  date: 2012-04-27
  slug: how-quickui-controls-use-code-to-specialize-the-handling-of-their-content-in-ways-that-might-not-be-supported-by-web-components
  originalUrl: http://blog.quickui.org/2012/04/27/how-quickui-controls-use-code-to-specialize-the-handling-of-their-content-in-ways-that-might-not-be-supported-by-web-components/
  ---
  As indicated in the earlier overview comparing <a href="http://blog.quickui.org/2012/04/16/a-vision-for-coevolving-quickui-and-the-emerging-web-components-standard/">QuickUI and Web Components</a>, one significant difference between the two frameworks is that QuickUI allows code to run when a control’s content() property is set, while the Web Components spec does not currently allow for this. This post will attempt to begin making the case for the need for this feature, starting with an analysis of how that feature is used in QuickUI controls today.

  The largest public body of QuickUI controls is <a href="http://quickui.org/catalog">QuickUI Catalog</a>, which as of this writing includes 76 open source controls that handle a variety of common user interface tasks or serve as demonstrations of how to achieve common behaviors in controls. Of the 76 published controls:
  <ul>
    <li>32 controls include code that runs when their content() property is set. Since the base Control class already provides a default content() property, these controls are overriding that base implementation. (In some cases, like <a href="http://quickui.org/catalog/PopupSource">PopupSource</a>, the class’ content() property override is itself overridden by a subclass like <a href="http://quickui.org/catalog/ComboBox">ComboBox</a>.)</li>
    <li>Of the above 32 controls, 23 use their content() property override to delegate content to a sub-element. This is the standard approach in QuickUI for a control to incorporate content from its host. (For a working example, see this <a href="http://jsfiddle.net/quickui/ys2JQ/">jsFiddle</a>, in which a UserTile control delegates its content to a span inside the control. This topic is also covered in the second portion of the QuickUI JavaScript <a href="http://quickui.org/tutorial">tutorial</a>.) This is roughly analogous to what Web Components spec accomplishes with the proposed &lt;content&gt; element.</li>
    <li>12 controls (of the 76 in the catalog) are text box variations that delegate their content() property to a text box: either an &lt;input&gt; element of type “text” or a &lt;textarea&gt;. For example, the content() of a <a href="http://quickui.org/catalog/ListComboBox/">ListComboBox</a> will be placed inside an &lt;input&gt;. Historically, HTML input fields have insisted on handling the field’s value through a string “value” property, whereas an element’s content is a DOM subtree. Despite the difference in data type, in many cases the distinction between “value” and “content” feels somewhat arbitrary. The convenience of a content property is just as interesting to a control that wants to render that content in a text box. For example, if a combo box is going to hold a list of animal names, it’s nice to be able to set the default content of that combo box in markup as:&lt;ListComboBox&gt;Dog&lt;/ListComboBox&gt;. Naturally, this translation is lossy: if one passes a DOM subtree into such a control’s content() property, it’s to be expected that it will only preserve the subtree’s text. Nevertheless, it is highly useful to be able to define controls that render their primary content in text boxes.</li>
    <li>20 of the controls override their content() property to perform work whenever the content changes. The following table summarizes these 20 cases:</li>
  </ul>
  <table width="585" border="0" cellspacing="0" cellpadding="0">
  <tbody>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><strong>Control</strong></td>
  <td valign="top" width="376"><strong>When content() property is set, the control…</strong></td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/AutoSizeTextBox">AutoSizeTextBox</a></td>
  <td valign="top" width="376">Recalculates its own height to match that of the content.</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/ColorSwatchButton">ColorSwatchButton</a></td>
  <td valign="top" width="376">Transforms a string color name/value into a color.</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/ColorSwatchTextBox">ColorSwatchTextBox</a></td>
  <td valign="top" width="376">Transforms a string color name/value into a color.</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/HighlightEffects">HighlightEffects</a></td>
  <td valign="top" width="376">Recalculates its height/width.</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/HintTextBox">HintTextBox</a></td>
  <td valign="top" width="376">Shows hint text if the content is empty.</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/Menu">Menu</a></td>
  <td valign="top" width="376">Recalculates the width of a subelement (a “shield” element that must be exactly as wide as the content to achieve a particular visual effect).</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/PackedColumn">PackedColumns</a></td>
  <td valign="top" width="376">Recalculates its layout.</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/PanelWithOverflow">PanelWithOverflow</a></td>
  <td valign="top" width="376">Recalculates its layout.</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/PersistentPanel">PersistentPanel</a></td>
  <td valign="top" width="376">Checks to see whether the panel should be docked or not.</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/PopupButton">PopupButton</a></td>
  <td valign="top" width="376">Adjusts its layout if the content is not empty.</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/Repeater">Repeater</a></td>
  <td valign="top" width="376">Copies the content into the array of repeated sub-controls.</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/SearchBox">SearchBox</a></td>
  <td valign="top" width="376">Enables its search icon if the content is not empty.</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/SlidingPages">SlidingPages</a></td>
  <td valign="top" width="376">Recalculates its height/width.</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/SlidingPagesWithDots">SlidingPagesWithDots</a></td>
  <td valign="top" width="376">Updates the number of page buttons to match the number of pages (i.e., child nodes) in the content.</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/Switch">Switch</a></td>
  <td valign="top" width="376">Determines which child should be visible.</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/Tab">Tab</a></td>
  <td valign="top" width="376">Lets the parent tab set know the tab’s size may have changed.</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/TabSet">TabSet</a></td>
  <td valign="top" width="376">Creates a tab button for each tab page.</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/TextBox">TextBox</a></td>
  <td valign="top" width="376">Generates a programmatic “change” event.</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/TextCondenser">TextCondenser</a></td>
  <td valign="top" width="376">Determines whether the text should appear condensed to help it fit.</td>
  </tr>
  <tr>
  <td valign="top" width="32"></td>
  <td valign="top" width="175"><a href="http://quickui.org/catalog/ValidatingTextBox">ValidatingTextBox</a></td>
  <td valign="top" width="376">Validates the contents.</td>
  </tr>
  </tbody>
  </table>
  To summarize, these controls are doing the following types of work when their content changes:
  <ul>
    <li>Adjust its dimensions or the dimensions of some subelements (e.g., AutoSizeTextBox, Menu).</li>
    <li>Layout contents to achieve results not directly supported in HTML and CSS (e.g., PackedColumns, PanelWithOverflow).</li>
    <li>Transform or manipulate the content before rendering it (e.g., Repeater, ColorSwatch).</li>
    <li>Update its own subelements based on the content (e.g., TabSet, SlidingPagesWithDots).</li>
    <li>Validating content (e.g., ValidatingTextBox, and its subclasses like <a href="http://quickui.org/catalog/DateTextBox/">DateTextBox</a>).</li>
  </ul>
  Such controls represent a significant percentage of the QuickUI Catalog — approximately 25% — and it’s very likely that similar results would be found in other QuickUI-based projects. And in addition to the scenarios listed above, other scenarios likely exist in which a control wants to perform work when its content changes.

  Overall, this pass through the QuickUI Catalog suggests that many interesting user interface components have a need to perform work when their content is set — to do something more than passively hold the content they’re passed. At this point, it’s not exactly whether the aforementioned QuickUI controls could be successfully ported to Web Components as the spec currently stands, which would be unfortunate. (As stated in the previous post, a long-term vision for the QuickUI framework is that controls created in QuickUI can be transitioned to a Web Components foundation in the future.)

  It’s possible that a component could use forthcoming support for DOM mutation observers could be used to track changes to its own content, but whether this would work, or work well, is not yet known. A control could also force its host to invoke some method on the control whenever the host changes the control’s content, but that would be unfortunate; it would place extra work on the developer, and a host’s failure to properly notify the control that its contents have changed could lead to subtle bugs.

2012-04-07.html: |
  ---
  title: "QuickUI now lets you create user interface controls in CoffeeScript"
  date: 2012-04-07
  slug: quickui-now-supports-coffeescript
  originalUrl: http://blog.quickui.org/2012/05/07/quickui-now-supports-coffeescript/
  ---
  QuickUI now supports the use and creation of web user interface controls in <a href="http://jashkenas.github.com/coffee-script">CoffeeScript</a>, a language that adds many useful features to the JavaScript language. Through its compiler, CoffeeScript can be easily used as a replacement for JavaScript in many web projects.

  QuickUI turns out to be a natural fit for CoffeeScript. One of the nice features in CoffeeScript is that you can create classes with the language’s built-in “class” syntax. You can take advantage of that syntax to create new QuickUI control classes, simply by extending the base Control class or any other control class:
  <pre># A simple button class in CoffeeScript
  class window.HelloButton extends BasicButton
    constructor: -&gt; return Control.coffee()
    inherited:
      content: "Hello, world!"
    genericSupport: true</pre>
  QuickUI control classes are subclasses of jQuery, so one of the key features in QuickUI’s new support for CoffeeScript is actually being able to create jQuery subclasses in CoffeeScript. CoffeeScript generates a prototype-based class that is similar to the classes produced by jQuery’s <a href="http://api.jquery.com/jQuery.sub/">$.sub()</a> feature (a core part of jQuery that will be moved to a plugin in jQuery 1.8), but jQuery’s classes require a rather Byzantine construction sequence. This is handled through the boilerplate constructor shown above. When Control.coffee() is called, it fixes up the CoffeeScript class so that it conforms to jQuery’s notion of how its class constructors should work.

  With this in place, it’s now possible to create QuickUI controls in CoffeeScript with significantly less source code than the equivalent plain JavaScript. This is an overall win for web UI developers. If your team hasn’t already taken a look at CoffeeScript, now might be a good time.

  Creating QuickUI controls in CoffeeScript currently requires a plugin, but the plan is to fold CoffeeScript support directly into the quickui.js runtime. Read the <a href="http://quickui.org/docs/CoffeeScript.html">documentation for QuickUI support of CoffeeScript</a> for more details.

2012-04-15 17:32:51.html: |
  ---
  title: "QuickUI 0.9: a significant update"
  date: 2012-04-15 17:32:51
  slug: quickui-0-9-a-significant-update
  originalUrl: http://blog.quickui.org/2012/05/15/quickui-0-9-a-significant-update/
  ---
  <p>QuickUI 0.9 has been released. This is a major update which includes a number of changes that make it easier than ever to create reusable, extensible web user interface components.</p> <ul> <li>The means by which classes are defined has been substantially simplified, which means that QuickUI is doing a lot less work when a class is defined. One result is that the previous Control.subclass() method has been replaced with a simple jQuery.sub() call. An overload still permits one to pass in a JavaScript object defining the class, but now everything in that object is simply copied over to the new class’ prototype. A new “inherited:” key now holds the Control JSON used to render the control; see the <a href="http://quickui.org/docs/control-JSON.html">docs</a> for more details. <li>The way you refer to an element within a control’s DOM has changed. Previously, you set an ID on an element in Control JSON using an “id:” key. Under the covers, this set an ID on the HTML element. As of QuickUI 0.9, to refer to an element in code, the Control JSON should include a “ref:” key. (See the <a href="http://quickui.org/tutorial/element-reference-functions.html">tutorial example</a>.) Under the covers, this will set a CSS class on the element. As before, this also implicitly creates an element reference function you can use to get that element through code: e.g., setting ref: “foo” on an element lets you get back to that element with the element reference function $foo(). <li>A control’s initialize() method now implicitly invokes the initialize() methods of its base classes. Previously, you had to remember to have initialize() invoke this._super(), which was error prone. Failure to invoke this._super() would often mean that a base class’ event handlers didn’t get wired up, which could lead to bugs which were difficult to track down. <li>CoffeeScript support, <a href="http://blog.quickui.org/2012/05/07/quickui-now-supports-coffeescript/">announced earlier</a>, has been folded into the core quickui.js runtime.</li></ul> <p>While the above work was underway, the QuickUI source code was substantially overhauled:</p> <ul> <li>The aforementioned support for creating QuickUI controls in CoffeeScript has gone so well that QuickUI’s own runtime has now itself been ported to CoffeeScript. This does <em>not</em> mean that QuickUI developers need to use CoffeeScript; QuickUI supports plain JavaScript development and CoffeeScript development equally well. For people using QuickUI, this simply means that a number of planned improvements to QuickUI (including those listed above) could more easily be tackled. <li>The quickui.js runtime file itself is now built with Ben Alman’s handy <a href="https://github.com/cowboy/grunt">Grunt</a> build tool. <li>The optional QuickUI markup compiler has been moved into a separate GitHub repo, quickui-markup.</li></ul> <p>Please take a look!</p>
    ------
2012-04-15 21:55:29.html: |
  ---
  title: "Some observations on porting the QuickUI runtime from plain JavaScript to CoffeeScript"
  date: 2012-04-15 21:55:29
  slug: porting-quickui-to-coffeescript
  originalUrl: http://blog.quickui.org/2012/05/15/porting-quickui-to-coffeescript/
  ---
  This post shares some highlights of the experience porting a non-trivial library from plain JavaScript to CoffeeScript in case other parties are considering a similar transition.

  Yesterday's <a href="http://blog.quickui.org/2012/05/15/quickui-0-9-a-significant-update/">announcement of QuickUI 0.9</a> mentioned that the framework source code has now been ported to CoffeeScript. The QuickUI framework is intended for plain JavaScript development as well; nothing in the change of source language changes that. But experimentation with the CoffeeScript language suggested there were enough advantages to the language that, going forward, it would be worth porting the runtime from plain JavaScript to CoffeeScript.

  Overall, the port from plain to JavaScript to CoffeeScript went rather smoothly, and the bulk of it took about two days. The QuickUI runtime, quickui.js, is a reasonably complex JavaScript library, which is to say that it's not a toy or trivial sample application. The last plain JavaScript version of the QuickUI runtime, quickui-0.8.9.js, was about 7700 lines of plain JavaScript (including comments), or about 60K, developed over the course of four and a half years.
  <h2>Automatic translation with js2Coffee</h2>
  The handy <a href="http://js2coffee.org/">js2coffee</a> conversion tool was used to kickstart the port. Kudos to Rico Sta. Cruz for this great tool.
  <ul>
    <li>The automatically translated CoffeeScript immediately passed 97% of the QuickUI unit test suite. The remaining 4 broken tests were do to a single <a href="https://github.com/rstacruz/js2coffee/issues/138">issue</a> related to translation of the "instanceof" keyword, which was easy enough to work around.</li>
    <li>The one thing js2coffee doesn't translate (yet) are comments, so these had to be copied over by hand. Tedious, but straightforward.</li>
    <li>Similarly, the js2coffee output sometimes produced long lines that needed to be hand-broken for legibility. Again, a bit tedious but straightforward.</li>
    <li>Once all unit tests passed, the unit tests themselves were ported to CoffeeScript by the same process.</li>
  </ul>
  After about a morning of work, a CoffeeScript-based quickui.js was functional. It passed all unit tests, and could actually be used to drive a non-trivial QuickUI-based body of code like the <a href="http://quickui.org/catalog">QuickUI Catalog</a>.
  <h2>Towards idiomatic CoffeeScript</h2>
  After the mechanical port with js2coffee, various CoffeeScript idioms were applied incrementally to replace the standard JavaScript idioms with their more concise CoffeeScript versions. This took another day and half or so.
  <ul>
    <li>There was occasion to use pretty much all of CoffeeScript's syntactic sugar. References to Foo.prototype.bar() were replaced with the more concise Foo::bar(). Closure variables to hold "this" for use in an event handler were replaced with CoffeeScript's "=&gt;" syntax. Etc., etc.</li>
    <li>Because CoffeeScript can wrap a body of code in a single function closure, this no longer needed to be done by hand. A wrapping closure like that can complicate the management of a pile of plain JavaScript files. The closure will typically have to be created through a build process that includes a JavaScript fragment (to start the closure) before the real JavaScript files, and another fragment (to end the closure) afterwards. (The jQuery <a href="https://github.com/jquery/jquery/blob/master/Makefile">Makefile</a> does this, for example.) CoffeeScript's built-in support for a closure that spans multiple files finally made it easy enough to break up the quickui.js runtime from a single monolithic JavaScript file into a much saner and more manageable collection of CoffeeScript files. That is, while the same degree of manageability could have been achieved in plain JavaScript, CoffeeScript made it simple enough that it actually got done.</li>
    <li>The QuickUI runtime itself doesn't create many classes, but in some cases (e.g., the unit test suite), classes could be created via CoffeeScript's concise class syntax. This took advantages of QuickUI's new support for <a href="http://quickui.org/docs/CoffeeScript.html">creating web user interface controls using CoffeeScript class syntax</a>.</li>
    <li>JavaScript "for" loops were replaced with CoffeeScript list comprehensions.</li>
  </ul>
  <h2>Idiomatic CoffeeScript iteration over jQuery objects</h2>
  <div>Speaking of "for" loops, it turns out that a good deal of the QuickUI runtime deals with looping over jQuery objects. QuickUI controls are a subclass of jQuery object, and when looping over them in plain JavaScript, it's often convenient to use jQuery's $.each() function. For example, this function invokes foo(), a jQuery method or plugin, on each element in a jQuery object:</div>
  <pre>var $elements = $(".someClass");
  $elements.each( function( index, element ) {
      $( element ).foo();
  });</pre>
  <div>Note that $.each() gives the callback the plain DOM element, so you have to wrap that element with $(element) to get a jQuery object you can then manipulate. To simplify that, QuickUI's runtime has long had a helper function called eachControl() that gives the callback the element as a wrapped jQuery object. (In QuickUI's case, it also ensures the control's particular subclass of jQuery is used, so that you can directly manipulate the control with that control's own specific API.) E.g.:</div>
  <pre>var $buttons = $(".BasicButton");
  $buttons.eachControl( function( index, $button ) {
      $button.foo();
  });</pre>
  <div>To take best advantage of CoffeeScript's supports for looping constructs, a simple jQuery plugin was created to create an array that can directly be used by CoffeeScript's "for" loop and list comprehensions. This plugin, called Control.segments(), converts a jQuery object that holds a number of elements into an array of jQuery objects that each hold a single (wrapped) element. The definition of segments() in CoffeeScript is trivial:</div>
  <div>
  <pre>Control::segments = -&gt;
    ( @constructor element for element in @ )</pre>
  </div>
  <div>QuickUI defines segments() on the Control class so as not to pollute the general jQuery plugin namespace, but the above definition could just as easily be done as jQuery::segments to create a plugin that worked with any jQuery object. In any event, the result of applying segments() to a jQuery object is an array that can be directly iterated over, while at the same time preserving type information.</div>
  <pre>$button.foo() for $button in Control(".BasicButton").segments()</pre>
  <div>Here, the looping variable $button ends up holding an instanceof BasicButton (which is also an instanceof jQuery), so $button.foo() invokes BasicButton.prototype.foo().</div>
  <div></div>
  <div>This "for" loop feels more direct and idiomatic in CoffeeScript than the standard $.each() approach. (In fact, it'd be nice if $.each() were extended so that, if invoked without arguments, it returned an array just like segments() does here.) This segments() call can also be used in CoffeeScript list comprehensions, thereby replacing many situations in which $.map() is currently used. A <a href="http://jsperf.com/each-vs-conversion-to-array-and-then-loop">jsperf experiment</a> suggests the segments() approach performs roughly as well as the standard $.each(). The generated JavaScript for segments() does build a temporary array of results, but it avoids the need for the callback function and the accompanying closure.</div>
  <div></div>
  <h2>Impressions</h2>
  <div>The new, CoffeeScript-based QuickUI source code gets compiled to a plain JavaScript file that's essentially the same size as the handwritten JavaScript (61K vs 60K). The new runtime appears to perform and function just as well as the earlier plain JavaScript one, so QuickUI developers shouldn't notice any difference. At the same time, the new CoffeeScript source code <em>feels</em> a lot tighter and easier to read and maintain.</div>
  <div></div>
  <div>This ability to write tighter code has already invited the successful implementation of a number of long-planned improvements to the runtime. It's hard to say how many of those improvements were easier to tackle because of advantages in the CoffeeScript language itself, and how many were tackled just because CoffeeScript is a shiny, new tool. But as a general rule, it seems that CoffeeScript permits a programmer to more directly express their intention than one can do in JavaScript — and any language that can do that is a step forward.</div>
  <div></div>
  <div>Best of all, using any language like CoffeeScript that compiles to plain JavaScript enables a developer to finally break a hard dependence between language choice and the user's browser. Now that QuickUI itself is written in CoffeeScript, it can take immediate advantage of improvements in CoffeeScript the day they appear, instead of waiting years for incremental JavaScript improvements to make their way through committee, into browsers, and into users' hands.</div>

2012-06-07 17:28:08.html: |
  ---
  title: "QuickkUI 0.9.1 released"
  date: 2012-06-07 17:28:08
  slug: quickui-0-9-1-released
  originalUrl: http://blog.quickui.org/2012/06/07/quickui-0-9-1-released/
  ---
  QuickUI 0.9.1 contains two changes:

  First, it’s now even easier to create web user interface components in CoffeeScript. When CoffeeScript support in QuickUI was <a href="http://blog.quickui.org/2012/05/07/quickui-now-supports-coffeescript/">first announced</a> a month ago, you had to include a boilerplate constructor. This was required to work around a limitation in CoffeeScript, in which CoffeeScript’s default constructor for a class didn’t return a value. (See <a href="https://github.com/jashkenas/coffee-script/issues/1966">a good summary of the issue here</a>.) That issue has now been <a href="https://github.com/jashkenas/coffee-script/pull/1970">fixed</a> in CoffeeScript 1.3.3. With a considerable degree of rework in the base Control class, you can now create a new user interface control in a single line of CoffeeScript:
  <pre>control window.MyButton extends BasicButton</pre>
  The QuickUI <a href="http://quickui.org/docs/CoffeeScript.html">documentation for creating controls in CoffeeScript</a> has been updated to reflect this.

  Second, QuickUI 0.9.1 has a simplified model for generic styling. The QuickUI Catalog controls define generic styles that allow them to function without you needing to provide styling for them. You can easily turn off a base class’ generic style by setting the subclass’ <a href="http://quickui.org/docs/control-prototype-methods.html#generic">generic()</a> property to false.

2012-06-07 18:51:51.html: |
  ---
  title: "How jQuery instantiates objects as jQuery.fn.init, and what that means if you want to subclass jQuery"
  date: 2012-06-07 18:51:51
  slug: jquery-fn-init
  originalUrl: http://blog.quickui.org/2012/06/07/jquery-fn-init/
  ---
  In order for the <a href="http://blog.quickui.org/2012/06/07/quickui-0-9-1-released/">recent release of QuickUI 0.9.1</a> to support concise creation of control classes in CoffeeScript, it was necessary to go deep into the bowels of jQuery’s class constructor to determine how it worked. Those findings are documented here in case others have a similar need to subclass jQuery, or would like to address the same need that drove jQuery to its current implementation.

  The jQuery class constructor can be found in <a href="https://github.com/jquery/jquery/blob/master/src/core.js">core.js</a>:
  <pre>jQuery = function( selector, context ) {
      // The jQuery object is actually just the init constructor 'enhanced'
      return new jQuery.fn.init( selector, context, rootjQuery );
  }</pre>
  But the comment doesn't do much to explain why init exists, or how it works.

  All jQuery developers are familiar with the form $(“div”), which is a shorthand for the longer jQuery(“div”). This, we are told, returns a new jQuery object. Actually, from the above constructor, we can see that what it <em>really</em> returns is an instance of the jQuery.fn.init class. (From here on out, we’ll just refer to that class as “init”.) The init constructor is defined like so:
  <pre>jQuery.fn = jQuery.prototype = {
      init: function( selector, context, rootjQuery ) {
          ...
      }
  }</pre>
  Here, first note that jQuery.fn is just a synonym for jQuery.prototype. Given that, we see that the init class constructor hangs off the jQuery prototype. Stashing the init class on the jQuery class’ prototype allows the jQuery library to avoid polluting the JavaScript global namespace with an extra class. (Of course, init could easily have been defined inside the outer jquery.js function closure, which would avoid namespace pollution and prevent access to it from outside. The init class isn't really referred to elsewhere in the jQuery source, so it's not immediately clear why that wasn't done. Perhaps the above approach makes for easier debugging.)

  Further on, we see this init class defined as a subclass of the jQuery class:
  <pre>// Give the init function the jQuery prototype for later instantiation
  jQuery.fn.init.prototype = jQuery.fn;</pre>
  Since jQuery.fn is just an abbreviation for jQuery.prototype, the above line is really:
  <pre>jQuery.prototype.init.prototype = jQuery.prototype;</pre>
  This ensures that any instance of init will also be a functional instance of jQuery. This can be confirmed in the debugger:
  <pre>&gt; $e = $("div")
  &gt; $e instanceof jQuery
  true
  &gt; $e instanceof jQuery.fn.init
  true</pre>
  So all those times when you create an instance of jQuery you are <em>actually </em>working with an instance of a jQuery <em>subclass</em>.

  Okay, but why bother? One reason is that jQuery wants to support a static constructor form: one you can invoke with needing to specify “new”. Regardless of whether you invoke the jQuery() constructor with “new” or not, it’s always going to return an instance of the init class. And, because init is a subclass of jQuery, you’ll end up with an instance of jQuery, which is what you wanted.
  <pre>// The following lines are all equal.
  var $e = new jQuery("div");
  var $e = jQuery("div");
  var $e = new $("div");
  var $e = $("div");</pre>
  So at least one reason init exists is that it serves as a helper class to let you write shorter jQuery code. The thing is, supporting instantiation without "new" doesn't require defining a separate helper class.

  The jQuery constructor above is relying upon an oddity in the JavaScript language: a constructor can return an object that’s an instance of a class other than the class defined by the constructor. The jQuery class could more easily use the simpler <a href="http://jimmycuadra.com/posts/javascript-factory-constructors">factory constructor</a> pattern to check to see whether it's been invoked without "new" (in which case "this" will be the window) and, if so, just return a new instance of itself. That is, in fact, how jQuery worked back in <a href="http://code.jquery.com/jquery-1.1.js">jQuery 1.1</a>:
  <pre>var jQuery = function(a,c) {
      // If the context is global, return a new object
      if ( window == this )
          return new jQuery(a,c);
      ...
  };</pre>
  By jQuery 1.2, however, the jQuery constructor was using the technique shown above. It's hard to tell from the code exactly why the init helper class was introduced. One possibility is that init has that extra rootjQuery parameter which is for internal use only. Burying that parameter in a helper class avoids having to expose the parameter in the jQuery API, where it might confuse jQuery developers or, worse, encourage them to create code that depends upon that parameter.

  <strong>Subclassing jQuery</strong>

  One cost of jQuery’s class scheme is that it makes it much harder for <em>you</em> to subclass jQuery. One reason you might want to do this is to provide scoping for your own jQuery plugins. If you want to add a lot of plugins to jQuery’s prototype (which, as indicated above, is what you’re doing when you add something to jQuery.fn), you could potentially pollute the jQuery namespace and run into conflicts with other plugins. By subclassing jQuery, and working strictly with instances of your subclass, you hide all your plugins from anyone who’s directly instantiating the plain jQuery class.

  Unfortunately, because of this init helper class, the normal JavaScript prototype-based subclassing scheme won’t work with jQuery. To make your subclass jQuery-like, you end up needing to replicate jQuery’s complex helper class arrangement: create a subclass of jQuery <em>and</em> a companion init helper class, derive your helper class from your actual jQuery subclass, and ensure your subclass’s constructor actually returns an instance of your init class.

  The mind-breaking pain of all that is presumably what led to the creation of a jQuery function called <a href="http://api.jquery.com/jQuery.sub/">$.sub()</a>. That function does exactly what’s described above: it defines a new subclass of jQuery and a companion init helper class.

  The $.sub() plugin doesn’t seem to be used much, perhaps because its benefits and reason for existence aren’t well-documented. The announced plan is that $.sub() will be removed from the core jQuery library in version 1.8, and transition to become an official plugin. As a result, $.sub() is deprecated as a <em>native </em>jQuery feature, but $.sub() and its technique will continue to be useful, so it’s still worth understanding and considering it.

  QuickUI relies upon the $.sub() technique to make its base Control a subclass of jQuery. This is what lets you use any jQuery feature with QuickUI controls directly: you can bind events to them with $.on(), you can style them with $.css(), and so on. That’s because your control class derives from Control, and so ultimately derives from jQuery.

  You can <a href="http://quickui.org/tutorial/creating-control-class.html">create a new QuickUI control class in JavaScript</a> by invoking Control.sub(). And, with QuickUI 0.9.1, you can now create subclasses of Control (and, therefore, jQuery ) <a href="http://quickui.org/docs/CoffeeScript.html">using CoffeeScript’s built-in class syntax</a>, which is concise and highly legible. In either language, you can easily create your own reusable web user interface components that have direct access to all the power of jQuery.

2012-06-18.html: |
  ---
  title: "Sample Contacts applicatiousing Backbone and QuickUI"
  date: 2012-06-18
  slug: sample-contacts-application
  originalUrl: http://blog.quickui.org/2012/06/18/sample-contacts-application/
  ---
  Back in April, someone evaluating QuickUI made the completely reasonable request to see a complete sample application created in QuickUI. More specifically, they were interested in seeing a demonstration of how to use QuickUI as the View in an MVC (Model-View-Controller) application, ideally using the popular <a href="http://backbonejs.org/">Backbone.js</a> library. QuickUI is well suited to fill that role, and a sample application has now been created to show off how to do exactly that.

  <a href="http://quickui.org/docs/contacts.html"><img src="http://quickui.org/docs/images/Contact%20Card.png" alt="" /></a>

  The result is a <a href="http://quickui.org/docs/contacts.html">sample Contacts application</a> built in QuickUI. The sample takes advantage of QuickUI’s support for CoffeeScript, which turns out to be an elegant language to express both Backbone and QuickUI classes.

  Read the sample’s documentation for more details of its construction.

2012-07-02.html: |
  ---
  title: "The Web Components spec should add support for multiple, named, DOM-valued properties"
  date: 2012-07-02
  slug: web-component-properties
  originalUrl: http://blog.quickui.org/2012/07/02/web-component-properties/
  ---
  At last week's Google I/O 2012 conference, Chrome engineers Alex Komoroske and Dimitri Glazkov gave a talk called, <a href="https://www.youtube.com/watch?v=2txPYQOWBtg">The Web Platform’s Cutting Edge</a>, a good overview of Web Components and <a href="http://www.w3.org/TR/components-intro/#custom-element-section">custom elements</a> in particular. The demo code shown in that presentation does point to an issue with the current Web Components spec that could seriously constrain the ease with which components can be written and shared. I’ll lay out the case here in hopes this problem can be fixed at an early stage.
  <h2>But first: A word of appreciation</h2>
  Authoring a spec for a new standard like Web Components is generally a thankless task, as is the tireless work of promulgating the standard through presentations like the one at Google I/O. So, before saying anything else: a big <strong>Thank You</strong> to Alex and Dimitri for their work on HTML Templates, Custom Elements, and Shadow DOM. Everything which follows is meant to support your work, not put it down.
  <h2>Background of the problem</h2>
  As I’ve blogged about before, I’m a passionate fan of web UI components and <a href="http://miksovsky.blogs.com/flowstate/2012/03/snapping-together-a-skyscraper.html">believe they will transform UI development</a>. The ability to define new elements for HTML is something designers and developers have long wanted but, until now, could only dream about. In the demo, Alex and Dimitri use Chrome’s early implementation of the proposed spec to create custom elements. They elegantly combine these elements to produce a custom UI component for a user poll:

  <a href="http://quickui.files.wordpress.com/2012/06/web-component-poll.png"><img style="background-image:none;padding-left:0;padding-right:0;display:inline;padding-top:0;border-width:0;" title="Web Component Poll" src="http://quickui.files.wordpress.com/2012/06/web-component-poll_thumb.png" alt="Web Component Poll" width="600" height="432" border="0" /></a>

  This poll user interface is a large component comprised of sub-components for accordions (or, later in the demo, tabs) and the big iconic choice buttons in the poll for “Semantics”, “Offline &amp; Storage”, etc. All these components are defined with declarative markup.

  I enthusiastically agree with the presenters that declarative HTML, including the ability to define custom elements, results in UI code that can be easier to read than a comparable imperative solution in JavaScript. And to its credit, most of the demo code shown in the presentation is self-explanatory.

  However, one aspect of the code really jumped out at me as a serious limitation of the current spec: a component host can only pass a single DOM content subtree to the component. As I’ll try to show, I believe that could seriously limit the degree to which a component can expose a meaningful API.

  Consider the markup behind those big “choice” buttons. Each choice component includes an icon, a short text summary used as a label, and longer descriptive text that appears in a tooltip on hover. You can think of that per-choice data as, in effect, three public properties of the choice component:
  <pre>&lt;element name=”x-choice” extends=”div” constructor=”ChoiceControl”&gt;
      &lt;template&gt;
          &lt;div id=”choice”&gt;
              &lt;div id=”icon” class=”mask”&gt;&lt;/div&gt;
              &lt;content select=”h3:first-of-type”&gt;&lt;/content&gt;
              &lt;aside&gt;
                  &lt;content select=”*”&gt;&lt;/content&gt;
              &lt;/aside&gt;
          &lt;/div&gt;
      &lt;/template&gt;
      …
  &lt;/element&gt;</pre>
  The code above makes use of the proposed &lt;content&gt; element to select specific portions of the DOM tree (using CSS selectors) and incorporate them into the component’s shadow DOM. With that in place, the code for the overall poll component (i.e., the choice host) can instantiate choice buttons with the following markup:
  <pre>&lt;x-choice value=”semantics”&gt;
      &lt;h3&gt;Semantics&lt;/h3&gt;
      &lt;p&gt;Giving meaning to structure, semantics are front and…&lt;/p&gt;
  &lt;/x-choice&gt;
  &lt;x-choice value=”offline-storage”&gt;
      &lt;h3&gt;Offline &amp; Storage&lt;/h3&gt;
      &lt;p&gt;Web apps can start faster and work even if there is no…&lt;/p&gt;
  &lt;/x-choice&gt;
  …</pre>
  So the first code fragment effectively defines a choice component with three public properties (although these aren't actually class properties). The second code fragment shows the creation of two instances of that choice component, filling in two of the three choice properties. It’s not shown where the icon property is filled in, but it’s presumably done through styling.

  All looks fine so far, but there are some serious issues lurking here.
  <h2>Problems</h2>
  The root issue here is that, as currently speced, <em>Web Components can only accept a single DOM-valued content property via markup</em>. This leads to a profusion of problems:
  <ol>
    <li>
  <h2>Asking developers to tease apart component content will mean work for devs, and produce inconsistent results.</h2>
  Why, exactly, is the choice component using the &lt;h3&gt; tag to specify the text label for the button? Because this component has two textual properties, and the current Web Components spec only lets the developer pass <em>one</em> DOM content subtree to a component. So the component's author developer has to somehow let the component's users pack more than one property into the content, and then the dev has to crack that content to extract those properties. The question of <em>how</em> to crack that single content subtree into multiple properties is left entirely up to the developer.

  The tool given to the developer for this purpose is CSS selectors, which at first glance seems powerful. Unfortunately, it’s also a recipe for inconsistency. Every developer will have the freedom—and chore—to approach this problem their own way, guaranteeing the emergence of a handful of different strategies, plus a number of truly bizarre solutions.

  It’s as if you were programming in a system where functions could only accept a single array. As it turns out, we already have a good, common example of a such a system: command line applications. Every command-line application has some main() function that’s handed a single array of command line options, and the application has to decide what to do with them. Although conventions eventually arose with respect to the order and meaning of arguments, there’s still a wide variety of approaches. Some apps rely on argument position, some rely on single-letter flags (“-a”), some rely on full-word named parameters (“--verbose"), some have idiosyncratic microgrammars (e.g., chmod permissions), and many applications support a rich combination of all these approaches.

  Parsing arguments is tedious, boring work. In the early days, a developer throwing an app together might do the absolute minimum work necessary. The result was often inconsistent or incomplete argument support. The dev might eventually be forced to hack on their app until they finally had a roughly functional command line parser. These days, developers can rely on language features, or libraries like Python’s argparse, to “crack” the argument array into a meaningful structure which can be more easily inspected. In particular, it’s invaluable to a developer to be able to directly inspect specific arguments by <em>name</em>.

  The use of CSS selectors does remove some of this tedium, but it still leaves devs without a consistent way to refer to component properties by name, thereby leaving the door wide open for inconsistency. A dev might decide to use DOM structure, HTML tags, element classes, or a combination of all of these to demarcate properties. This will make it much harder for devs to share components, to swap out one component for another, and so on. It would be better if we could learn from the command-line argument example now and head off this inconsistency.</li>
    <li>
  <h2>HTML semantics are nearly meaningless when used to identify parameters.</h2>
  In the Google I/O demo, the developer of the choice component elected to use HTML tags within the single content subtree to identify properties. In this case, they decided that the first &lt;h3&gt; element in the content would identify the summary text, and everything else would be used as the longer text description.

  But why use &lt;h3&gt; for this purpose? The W3C <a href="http://www.w3.org/TR/1999/REC-html401-19991224/struct/global.html#h-7.5.5">spec</a> says a heading tag like &lt;h3&gt; should be used to, “briefly describe the topic of the section it introduces”. These choices aren't introducing sections, so that can't be the the case here. Neither is this &lt;h3&gt; being used to reflect the rank of an element in a hierarchical document structure.

  In all likelihood, the &lt;h3&gt; is used here, as it often is in practice, to mean something like, “somewhat prominent, but not <em>too</em> prominent”. Visually this usually translates to, “bold text, a little bigger than the body text”. At least, that seems to be how &lt;h3&gt; is being used in this component.

  There's nothing really wrong with that, but it's clearly arbitrary. Other developers might easily make a different decision. Later, in the very same demo, the code for the poll component accepts the text label for a different Voting button through the use of a &lt;label&gt; element. So in one place in this app, a button’s label is specified with an &lt;h3&gt;, but elsewhere <em>in the same app</em>, a button’s label is specified with a &lt;label&gt;. I don’t think this reflects any particular negligence on the part of the demo’s developers. I think it’s a latent issue in any scheme that relies on HTML elements for something than the original purpose. Perhaps the code' s developers did have some reason in mind for using &lt;label&gt; in one place and &lt;h3&gt; in another, but the point is that the reason is not obvious to another party looking at the code.

  The same arbitrary nature of tag choice here applies to use of the &lt;aside&gt; tag to identify the choice description. Try this: show the poll screen shot above to 3 web developers, and ask them which HTML tag they would use to specify the tooltip that should appear when the user mouses over a choice button. I’d be surprised if even <em>one</em> of them picked the &lt;aside&gt; tag. Is the tooltip content here really, as the <a href="http://www.w3.org/wiki/HTML/Elements/aside">W3C description</a> says for the &lt;aside&gt; element, “tangentially related to the content around the aside element, and which could be considered separate from that content”? Well, not really. But, maybe; that’s a debatable point. The fact it’s debatable is what’s at issue here.

  In contrast, here’s a tautological statement which <em>wouldn’t</em> generate debate: the choice description in the tooltip is the choice description in the tooltip. The <em>local</em> semantics here aren’t in question. So it’s a shame the property can’t be described in contextual terms like “description”, or “tooltip”.

  The fact that the component is using HTML elements to identify arguments appears sensible, but in practice will be nearly meaningless. Every single time a dev needs to create a new component property, they’ll pick from the 100-odd HTML elements. Their selection may depend on their experience, their mood, the phase of the moon, and which handful of HTML elements they haven’t already used for <em>other</em> properties on the same component. It's highly likely a different developer (or the same developer on a different day) would make a different selection of HTML elements for the same properties.

  Imagine an object-oriented programming language that forced you to give class properties one of 100 sanctioned property names: “index”, “count”, “name”, etc. Evereyone’s classes would <em>look</em> consistent, but it would be an utterly false consistency. That’s effectively what we’ll get if component authors are forced to choose HTML tags to identify component properties.</li>
    <li>
  <h2>Use of CSS selectors hinders a developer’s ability to add new properties.</h2>
  Suppose the author of this component needs to add a new property to this choice component. Maybe they want to add a “More about this choice” link to each choice; this link should navigate to another page with more details on that poll choice. Following the example of the &lt;h3&gt; for the choice summary, they decide to define this link property by extracting the first &lt;a&gt; tag in the content to be the link to the “More about this choice” page.

  Perhaps, following their use of the “h3:first-of-type” selector above, they decide to pick out this &lt;a&gt; tag with the similar CSS selector “a:first-of-type”. If they do so, this component author will inadvertently screw up any component user who happened to include an &lt;a&gt; tag somewhere in the description. Suppose a user of this component has <em>already</em> created some code for a choice like this:
  <pre>&lt;x-choice value=”semantics”&gt;
      &lt;h3&gt;Semantics&lt;/h3&gt;
      &lt;p&gt;
          Semantics in &lt;a href=”…”&gt;HTML5&lt;/a&gt; applications…
      &lt;/p&gt;
  &lt;/x-choice&gt;</pre>
  The “a:first-of-type” selector for the “More about this choice” link will accidentally pick up the existing link, thereby breaking this use of the component. The component author could issue a “Breaking Change” notice, warning everyone to include an &lt;a&gt; tag before the choice description. But even that wouldn’t help someone who, for whatever reason, needed to embed an &lt;a&gt; inside of the &lt;h3&gt;.

  The use of selectors here could be made more robust by using the child selector "&gt;", as in "&gt; h3:first-of-type". But this gets verbose, and again, isn't likely to be a universal convention, and inconsistent use of the child selector will only add to the confusion. The fundamental problem is that using CSS selectors for this purpose is inherently fragile.</li>
    <li>
  <h2>Arbitrary parameter structure is brittle.</h2>
  The fragility of using CSS selectors remains even if one tries to avoid the use of arbitrary HTML elements. Suppose you decide to use element <em>position </em>to identify components. You’ll still up a component which is hard to update.

  Here, a relevant case study is the existing of positional function parameters in most programming languages. To take just one example, consider JavaScript functions. Suppose you’ve defined a function with three parameters: “function foo(a, b, c) {…}”. If you now want to add a new parameter “d”, you have to add it to the end of the argument list to avoid breaking existing users of your function. This can easily produce a function whose parameter order feels unnatural. And to use the new “d” parameter, a function caller <em>must </em>supply the intermediate arguments a, b, and c, even if those are irrelevant to the function call at hand.

  To avoid these problems, programming languages tend to eventually evolve named function parameters. Functions with named parameters are inherently more future-proof and, importantly, allow callers to only specify the parameters they care about.

  The lesson of positional function parameters applies to trying to parse component properties out of the DOM content subtree. Having learned this lesson in countless programming languages, it would be nice to just jump straight to a reasonable solution which allowed for named component properties. While CSS selectors represent a powerful parsing tool, much of that power is completely unnecessary in this context — and some people will inevitably put that extra power to poor use.</li>
    <li>
  <h1>Subclasses will compete for parameters with their base classes.</h1>
  The above situations quickly deteriorate further when one envisions extending an existing component via subclassing. Subclassing is a crucial means of efficiency in component development, in which the behavior of one component can be specialized for new purposes. As just one case, over 33% of the controls in the <a href="http://quickui.org/catalog">QuickUI Catalog</a> are subclasses of other Catalog controls. For example, both <a href="http://quickui.org/catalog/DateComboBox">DateComboBox</a> and <a href="http://quickui.org/catalog/ListComboBox">ListComboBox</a> extend <a href="http://quickui.org/catalog/ComboBox">ComboBox</a>, which itself extends <a href="http://quickui.org/catalog/PopupSource/">PopupSource</a>. This separation of concerns is vital to keep the code clean, organized, and maintainable.

  Such subclasses would likely become unworkable as Web Components, because each level of the class hierarchy will be competing with its ancestors and descendants as they all tried to extract properties from the single DOM content subtree permitted by the Web Components spec. If the choice class extracts an &lt;h3&gt; element from the content, then that element is effectively<em> invisible </em>to the &lt;content&gt; selectors of its subclasses. (Or, if you let subclasses have first shot at the content, then the elements they pull out are effectively invisible to their base classes.)

  This significantly complicates point #3 above (using CSS selectors to pull out properties from the DOM content subtree makes it hard to add new properties). Consider a subclass of the choice component above called, say, special-choice. Perhaps the author of special-choice has decided to use the HTML &lt;h4&gt; element to identify a particular property. Now the author of the base choice component decides to add a new property, and elects to use &lt;h4&gt; for this purpose themselves. This has the effect of breaking the special-choice subclass. Obviously, such naming conflicts can arise in regular OOP classes, but here the likelihood of conflict is much greater because of the highly constrained vocabulary of HTML elements.

  Using DOM structure to select properties (point #4, above) is even <em>more</em> brittle when one considers subclasses. If a component class decides to use DOM element position to select content for a given property, and someone creates a subclass that likewise uses element position, the original base class’ API is effectively frozen. Suppose the base class defines a &lt;content&gt; element with selector “:nth-child(3)” , and the subclass goes ahead and uses a &lt;content&gt; with selector “:nth-child(4)”. How is the base class supposed to add support for a new property now? They can’t use position 4, because a subclass is already using that.

  The situation could be worked around by requiring not just specific tags, but also specific class names, but this has problems of its own (see below).

  As currently drafted, the Web Components spec seems highly likely to close off the possibility of rich component hierarchies. Most component developers will probably elect to just copy-and-paste useful code from other developers, rather than subclassing them, to preserve the ability to modify their components in the future.</li>
    <li>
  <h2>Class names could help identify properties, but will probably just complicate everything.</h2>
  One way to skirt the problems above is to use HTML element classes to identify properties by class name, and reference these classes in the CSS selectors. If you gave up on specific HTML tags, and just used a &lt;div&gt; and a named element class for all properties, the second code fragment above could look like this:
  <pre>&lt;x-choice value=”semantics”&gt;
    &lt;div class=”summary”&gt;Semantics&lt;/div&gt;
    &lt;div class=”description”&gt;Giving meaning to structure…&lt;/div&gt;
  &lt;/x-choice&gt;
  &lt;x-choice value=”offline-storage”&gt;
      &lt;div class=”summary”&gt;Offline &amp; Storage&lt;/div&gt;
      &lt;div class=”description”&gt;Web apps can start faster…&lt;/div&gt;
  &lt;/x-choice&gt;
  …</pre>
  This could potentially work if everyone agreed to <em>always</em> using an element class name to identify a property, and consistently applied those classes to a single element type (likely &lt;div&gt;) which everyone agreed upon would stand for “parameter”.

  Unfortunately, the more likely result is that throwing element class names into the mix will just complicate everything further. Some devs will write their components that way, but others will insist the use of HTML elements as shown above. Some will require the use of both specific HTML elements <em>and</em> specific class names. E.g., the choice component’s summary property will be forced to be identified with &lt;h3.summary&gt; to avoid possible conflicts with other &lt;h3&gt; elements in the content. This would be verbose and, worse, as a component user you'd have to remember and specify <em>two</em> things, when one should be sufficient.</li>
    <li>
  <h2>Invisible component APIs foreclose the possibility of inspection and reflection.</h2>
  The choice component in this example effectively presents its hosts with an external API that allows the host to fill in two text properties. Unfortunately, that API is <em>implicit</em> in the design of the &lt;content&gt; elements and their selectors. That makes it hard to programmatically understand what a component is doing.

  At design time, there’s no easy way to statically analyze the code to inspect what those &lt;content&gt; elements are actually being used for. You could potentially parse the HTML to find the &lt;content&gt; elements, then parse their CSS selectors, but that still wouldn't give you any hints as to what those &lt;content&gt; elements were being used <em>for</em>. At least a formal property name gives you a real idea as to its purpose.

  And at runtime, there would be no easy way to ask a choice component instance questions about which properties it supports: “How many properties do you have?”, or “Do you have a ‘description’ property?” Such run-time inspection of a component’s API (also known as reflection) can be a powerful tool.

  In this very presentation, Google’s developers point toward the benefits of programmatic inspection when they observe that giving web developers the ability to create new custom elements (via the &lt;element&gt; tag) will open new possibilities in researching possible improvements to HTML itself. For example, researchers could statically inspect Web Components actually used by production web sites to determine, for example, the names of the most common custom elements. That in turn could help guide the formal adoption of new HTML elements in future versions of the language itself.

  That’s just one example of what’s possible when APIs are explicit. Such explicitness should be extended beyond component names to cover component property names as well.</li>
  </ol>
  <h2>A proposal to fix this: Support multiple, named, DOM-valued component properties</h2>
  All the issues above could be eliminated or dramatically improved if the Web Components spec were amended to let developers create components that accept multiple, named, DOM-valued properties. (Presumably, this support would actually be added to HTML Templates, used by both &lt;element&gt; and &lt;decorator&gt; elements.)

  Here are some possible syntax suggestions:
  <ul>
    <li>
  <h2>Proposal A: Use a consistent tag for component properties.</h2>
  A convention of using &lt;div&gt; elements to hold properties (see point #6 above) is a bit odd, because the &lt;div&gt; tag is used simply as a placeholder. The convention could be improved by formalizing a new element specifically for this purpose. Perhaps the existing &lt;param&gt; tag, currently limited to use within &lt;object&gt; elements, could be given new life by being repurposed for use within components. Its definition would need to be extended to support a closing &lt;/param&gt; tag form that could encapsulate a DOM subtree:
  <pre>&lt;x-choice value=”semantics”&gt;
      &lt;param name=”summary”&gt;Semantics&lt;/param&gt;
      &lt;param name=”description”&gt;Giving meaning to …&lt;/param&gt;
  &lt;/x-choice&gt;
  &lt;x-choice value=”offline-storage”&gt;
      &lt;param name=”summary”&gt;Offline &amp; Storage&lt;/param&gt;
      &lt;param name=”description”&gt;Web apps can start …&lt;/param&gt;
  &lt;/x-choice&gt;
  …</pre>
  If &lt;param&gt; can’t be redefined this way, then a new tag like &lt;property&gt; could be created.

  If HTML semantics zealots insist on mapping component content to HTML elements, it’d be possible to let define a component author identify a <em>backing</em> HTML semantic tag that should be used to treat the property’s content for search and other purposes. E.g., syntax within the &lt;element&gt; definition would indicate that the “summary” property should be backed by an &lt;h3&gt; element. This is exactly the way that the &lt;element&gt; tag’s “extends” attribute is already spec’ed to work. The author indicates that an &lt;x-choice&gt; element is backed by a &lt;div&gt;.

  In the exact same way, the author could indicate that a &lt;param&gt; (or &lt;property&gt;) of name=”summary” should be backed by an &lt;h3&gt;. As noted above, the particular choice of backing HTML element might be inconsistent or meaningless, but at least use of a backing element confines the problem to a much smaller audience. That is, the component <em>users</em> shouldn’t need to know that summary property behaves like an &lt;h3&gt;, just like they don’t have to know that an &lt;x-choice&gt; behaves like a &lt;div&gt;. Rather, that would be something only the component author would need to concern themselves with.</li>
    <li>
  <h2>Proposal B: Expand data- attributes to support data- elements</h2>
  HTML developers can already attach arbitrary string data to HTML elements as data- attributes (that is, element attributes prefixed with “data-”). Web Components could build on this precedent to allow data- <em>elements</em> that specify DOM subtrees nested within the component's content. For example:
  <pre>&lt;x-choice value=”semantics”&gt;
      &lt;data-summary&gt;Semantics&lt;/data-summary&gt;
      &lt;data-description&gt;Giving meaning to …&lt;/data-description&gt;
  &lt;/x-choice&gt;
  &lt;x-choice value=”offline-storage”&gt;
      &lt;data-summary&gt;Offline &amp; Storage&lt;/data-summary&gt;
      &lt;data-description&gt;Web apps can start …&lt;/data-description&gt;
  &lt;/x-choice&gt;
  …</pre>
  In the case where the property values are pure text, a &lt;data-foo&gt; element could be interchangeable with the corresponding data-foo attribute within the component tag. So one could also write:
  <pre>&lt;x-choice value=”semantics” data-summary=”Semantics”&gt;
      &lt;data-description&gt;Giving meaning to …&lt;/data-description&gt;
  &lt;/x-choice&gt;
  &lt;x-choice value=”offline-storage” data-summary=”Offline &amp; Storage”&gt;
      &lt;data-description&gt;Web apps can start …&lt;/data-description&gt;
  &lt;/x-choice&gt;
  …</pre>
  The data- element form would only need to be used when specifying a real DOM subtree with subelements; otherwise, the data- attribute form could be used.</li>
    <li>
  <h2>Proposal C (preferred): Let developers define custom property elements</h2>
  The above approach could be tightened further by dropping HTML’s historic obsession with restricting the set of tags. By dropping by the “x-“ in the custom element tag, and the “data-“ in the custom property tag, we end up with something much cleaner:
  <pre>&lt;choice value=”semantics”&gt;
      &lt;summary&gt;Semantics&lt;/summary&gt;
      &lt;description&gt;Giving meaning to structure, …&lt;/description&gt;
  &lt;/choice&gt;
  &lt;choice value=”offline-storage”&gt;
      &lt;summary&gt;Offline &amp; Storage&lt;/summary&gt;
      &lt;description&gt;Web apps can start faster …&lt;/description&gt;
  &lt;/choice&gt;
  …</pre>
  As with the data- element approach above, this custom property element approach could also support the use of a data- attribute on the element tag itself when specifying a simple string property value.

  The cleanliness of the code above comes at the cost of an ambiguity: if you can define your own element tags and property tags, how does the parser know which is which? In the code above, is &lt;summary&gt; a property of &lt;choice&gt;, or is it a custom element in its own right? One resolution would be a precedence rule, e.g., if &lt;summary&gt; is a child of a parent that has a summary property, then treat it as a property, otherwise instantiate it as a custom element. Another resolution would be to follow what Microsoft did with XAML's <a href="http://msdn.microsoft.com/en-us/library/ms788723.aspx#property_element_syntax">property element syntax</a>: allow (or require) the property to be written as &lt;choice-summary&gt;.

  As noted above, if HTML powers that be insist on mapping component content to a fixed set of HTML elements, that could  be handled by letting a component author indicate the HTML element which should be used to back each property. Again, that would relegate the problem to something that only the component author would have to worry about. The writer of the code above that hosts the choice component wouldn’t have to obsess over the question of why &lt;aside&gt; was picked instead of &lt;label&gt;; that detail would only be visible by reading the code for the choice component. The host author only has to deal with &lt;summary&gt;, which has local meaning.

  In any event, the above code sample is clean, and should serve as a goal. Such code would be a joy to write — and read. It moves HTML definitively towards the creation of domain-specific languages, which is where it should go.

  It’s somewhat absurd that we can only define markup terms according to global consensus. That’s like waiting for a programming language committee to approve the names of your classes. The web will move forward at a <em>much</em> faster pace if we can let individual problem domains (online stores, news sites, social networks, games, etc.) define their own tags, with semantics they care about and can agree upon. As the aforementioned uses of &lt;aside&gt; and &lt;label&gt; illustrate, forcing developers to use HTML elements may give the appearance of consistent semantics, but that consistency is merely a facade. In contrast, letting polling organizations define the meaning of a &lt;summary&gt; property for a &lt;choice&gt; component could produce meaningful consistency within that industry.</li>
  </ul>
  <h2>There’s still time to fix this</h2>
  In their presentation, Alex and Dimitri indicated that their goal is not to spec out a complete replacement for web UI frameworks. Rather, the goal of their work is to lay a solid foundation on top of which great web UI frameworks can be built by others. In this light, it is hoped that the Web Components spec can be amended to support multiple, named, DOM-valued properties — because that’s exactly the foundation a great web UI framework is going to need.

  The QuickUI framework, at least, is more expressive with regard to component content than is possible within the current Web Components spec. That is to say, the existing Catalog of QuickUI controls (and the many others controls written in the service of specific QuickUI-based applications) could not be ported to the current Web Components spec. Or, perhaps, those controls <em>could</em> be ported — but then, for the reasons given above, the collection would then become so brittle that its evolution would come to a halt. That would be a shame.

  To be sure, the Google team, and the others working on Web Components, are smart folks, and it’s likely they’ve already given at least some thought to the problems raised in this post. But more input, particularly when informed by real application experience by potential users of a standard, is always valuable in weighing decisions about what should go into the standard. And it's in that spirit that this post is written.

  If you yourself have worked with component frameworks, and have experiences that bear on this issue, please share them with the folks at Google. A good forum for feedback might be the <a href="https://plus.google.com/103330502635338602217/posts">Web Components page on Google+</a>. (Be sure to thank everyone for their work!)

2012-08-06.html: |
  ---
  title: "QuickUI 0.9.2 released"
  date: 2012-08-06
  slug: quickui-0-9-2-released
  originalUrl: http://blog.quickui.org/2012/08/06/quickui-0-9-2-released/
  ---
  <p>Version 0.9.2 is primarily a bug-fix release. Beyond a variety of minor fixes, there are just a couple of notable changes:</p> <ol> <li>Using $.control( element ) on an existing element to cast the element to the correct subclass of Control now returns null (instead of undefined) if the given element is not a control.</li> <li>A bug has been fixed which prevented quickui.js from loading in IE8. Thanks to QuickUI user Toussaint for reporting this bug and helping to test the fix!</li></ol> <p>The release of 0.9.2 coincides with the release of version 0.9.2 of the QuickUI Catalog, which includes the following:</p> <ol> <li>Modes now derives from a new base class called Sequence, a general-purpose class for any linear sequence of elements that can be navigated via a next() and previous() method. Modes now focuses on showing just one element of a Sequence at a time. As part of this change, Modes.activeChild() has been renamed to Modes.activeElement().</li> <li>SlidingPages has been renamed SlidingPanels (since its contained elements aren’t necessarily pages). The class now also derives from Sequence. Finally, SlidingPanels has been updated to take advantage of CSS transitions on browsers that support them, falling back to a jQuery animation on older browsers.</li> <li>LateralNavigator has been refactored to handle two general cases: first, navigating through a Sequence of elements, and second navigating through an abstract axis like time. The former case is specifically addressed with a new class called SequenceNavigator. The latter case is used in CalendarMonthNavigator.</li> <li>An issue that prevented CalendarMonthNavigator from correctly vertically aligning its heading elements has been fixed. CalendarMonthNavigator now also uses a new class, MonthAndYear, to show both the month and year instead of just the month name.</li> <li>A new VerticalAlign class handles the general problem of vertically aligning child elements in older browsers.</li> <li>A new Carousel class derives from SequenceNavigator, and uses a SlidingPanels class to provide a sliding transition between elements in the sequence.</li> <li>The TabSet class has been renamed to Tabs.</li></ol> <p>This release is also notable as the first one in which Catalog controls have been written (and, some cases, rewritten) in CoffeeScript.</p>

2013-01-12.html: |
  ---
  title: "QuickUI 0.9.3 released"
  date: 2013-01-12
  slug: quickui-0-9-3-released
  originalUrl: http://blog.quickui.org/2013/01/11/quickui-0-9-3-released/
  ---
  This minor release is being made now because it contains a fix for the forthcoming release of jQuery 1.9. Changes:
  <ul>
    <li>A new Control member called Control.browser replicates the behavior of the now-deprecated jQuery.browser member. jQuery is quite reasonably trying to encourage people to use feature-detection libraries like Modernizr instead of looking directly at the user agent to determine behavior, and jQuery 0.9 is removing support for jQuery.browser. However, in developing the QuickUI Catalog controls, minor bugs have been found time and again in specific browsers to prevent controls from working correctly. These bugs are the sorts of things that will never be detectable with a feature-detection library, and hence checking the browser's user agent is the only practical way to ensure cross-browser compatibility.</li>
  </ul>
  The corresponding release of QuickUI Catalog 0.9.3 includes some minor enhancements:
  <ul>
    <li><span style="line-height:15px;">A new <a href="http://quickui.org/catalog/TextBoxWithButton">TextBoxWithButton</a> control covers the common UI pattern of a text box with an adjacent button (often labeled "Go" or something similar). </span>The existing SearchBox control has been refactored to derive from TextBoxWithButton.</li>
    <li>A new <a href="http://quickui.org/catalog/Log">Log </a>control handles the common need to log text output (e.g., from a background process) to the page.</li>
  </ul>

2013-01-23.html: |
  ---
  title: "QuickUI Catalog 0.9.3.1 released"
  date: 2013-01-23
  slug: quickui-catalog-0-9-3-1-released
  originalUrl: http://blog.quickui.org/2013/01/23/quickui-catalog-0-9-3-1-released/
  ---
  The <a href="http://quickui.org/catalog">QuickUI Catalog</a> has been updated to version 0.9.3.1. This is a modest update in terms of functionality, but a significant milestone for the catalog — it represents the culmination of an effort to port all the Catalog controls to a combination of CoffeeScript and LESS.

  The original QuickUI framework included the use of a local build tool called the QuickUI markup compiler. This compiled a markup format that was essentially HTML plus the use of custom tags. (In this, the format was remarkably similar to the spec'ed format for Web Components.) Because this format never got any traction, it was eventually deprecated, although still used for the vast majority of the Catalog controls. 2013 has begun with a major push to port all these controls to CoffeeScript for content and behavior and LESS for appearance.

  Now that that port has been accomplished, it will be easier to move the Catalog forward, including the addition of new controls and some refactoring of existing ones. Along with this port, a handful of other controls were added to the Catalog:
  <ul>
    <li><a href="http://quickui.org/catalog/ToggleButton">ToggleButton</a> is a button that can track a selected state. This can be used as is, or as a base class for custom toggle classes.</li>
    <li><a href="http://quickui.org/catalog/Link">Link</a> wraps a standard HTML &lt;a&gt; tag, and can be used as a base class for custom link classes.</li>
    <li><a href="http://quickui.org/catalog/TextBox">TextBox</a> wraps a standard HTML text input element, and can be used as a base class for custom text box classes.</li>
  </ul>
    ------
2013-02-27.html: |
  ---
  title: "QuickUI breaks with CoffeeScript 1.5"
  date: 2013-02-27
  slug: quickui-breaks-with-coffeescript-1-5
  originalUrl: http://blog.quickui.org/2013/02/27/quickui-breaks-with-coffeescript-1-5/
  ---
  <p>Bad news: this week's release of CoffeeScript 1.5 is incompatible with even the current QuickUI release, 0.9.3.</p>
  <p>QuickUI goes through <a href="http://blog.quickui.org/2012/06/07/jquery-fn-init/">significant trouble to subclass jQuery</a> because of jQuery's complex constructor. jQuery depends on an unusual feature of JavaScript called an "other typed" constructor: a class constructor that returns something other than a plain instance of the class being instantiated. When the CoffeeScript project considered dropping support for such constructors, cases were made to keep that feature (see <a href="https://github.com/jashkenas/coffee-script/issues/2359">CoffeeScript issue #2359</a>, but other people made similar cases on other issues). However, those arguments did not carry the day, and as of CoffeeScript 1.5, "other typed" constructors are rejected by the compiler. This effectively breaks the CoffeeScript source for QuickUI itself as well as for QuickUI Catalog.</p>
  <p>Possible fixes are being investigated, but this issue runs very deep, and a number of straightforward workarounds have already been ruled out. A real fix will likely require a substantial change to the way QuickUI instantiates controls. For the time being, it is recommended that QuickUI developers use CoffeeScript 1.4.0.</p>

2013-04-13.html: |
  ---
  title: "QuickUI 0.9.4 released"
  date: 2013-04-13
  slug: quickui-0-9-4-released
  originalUrl: http://blog.quickui.org/2013/05/13/quickui-0-9-4-released/
  ---
  <p>This release fixes a number of small bugs in both QuickUI and the QuickUI Catalog.</p>
  <p>The most significant change is in the Control constructor. QuickUI previously went through a lot of trouble to <a href="http://blog.quickui.org/2012/06/07/jquery-fn-init/">subclass jQuery</a>. This code involved patching up a class when an attempt was made to instantiate it so that the result would be acceptable to jQuery. Specifically, the resulting patched-up class could be instantiated without requiring the "new" keyword. This code was quite complex and brittle, and was eventually <a href="http://blog.quickui.org/2013/02/27/quickui-breaks-with-coffeescript-1-5/">broken by a change to the CoffeeScript 1.5 compiler</a>. The CoffeeScript folks graciously backed out that change in CoffeeScript 1.6 so that QuickUI could continue to function.</p>
  <p>Meanwhile, a workaround had already begun to drastically simplify the Control constructor — in exchange for dropping the ability to instantiate a control class' constructor without the "new" keyword. As it turns out, QuickUI controls are typically instantiated via the framework itself, either declaratively through Control JSON or imperatively by invoking Control.create(). Only the framework needed to directly instantiate a control class, and so the framework source was updated to always make use of the "new" keyword.</p>
  <p>By the time this workaround was ready for deployment, the CoffeeScript 1.6 change made that workaround unnecessary. However, because the workaround was already working, and had significantly simplified the framework source, it was decided to keep the workaround. It was probably still correct for CoffeeScript 1.6 to back out the earlier breaking change to control constructors in CS 1.5. As this experience shows, the change not only dictated what CoffeeScript developers could do, it prevented or impaired their ability to integrated with plain JavaScript libraries which made use of "other typed" constructors.</p>
  <p>In general, despite this constructor change deep in the framework, QuickUI developers should generally observe no changes in framework behavior.</p>
  <p>The QuickUI Catalog has a few small bug fixes, but the version number has been bumped to 0.9.4.0 to keep in sync with the new version number for QuickUI 0.9.4.</p>
    ------
2013-06-03.html: |
  ---
  title: "Quetzal: an experimental translation of the QuickUI component model to HTML custom elements"
  date: 2013-06-03
  slug: quetzal-an-experimental-translation-of-quickui-component-model-to-html-custom-elements
  originalUrl: http://blog.quickui.org/2013/06/03/quetzal-an-experimental-translation-of-quickui-component-model-to-html-custom-elements/
  ---
  I've started an experiment called <a href="http://janmiksovsky.github.io/quetzal/">Quetzal</a> that considers translating the core concepts from QuickUI to the proposed web component standards currently embodied by Polymer.

  <i>[<b>Update</b> June 13, 2014: The Quetzal project has grown into an open source project called <a href="https://github.com/basic-web-components/components-dev/wiki">Basic Web Components</a>. Please take a look!]</i>

  While continuing working on QuickUI, I've been tracking the progress of the Google-led efforts on web components: custom elements, Shadow DOM, and related advances in the web platform. Those technologies address many of the same issues QuickUI addresses, so I've been trying to chart a path by which QuickUI and web components could co-evolve.

  Until recently, those web component technologies were generally available only on Google Chrome, which means QuickUI can't rely on them. However, since the start of the year I've been watching Google's <a href="http://www.polymer-project.org/">Polymer project</a> which, among other things, offers a suite of polyfills that allows one to create and use components in the <a href="http://www.polymer-project.org/compatibility.html">other "modern" browsers</a>, including recent versions of Safari, Firefox, and Internet Explorer 10+. Polymer offers a fairly compelling story for using those future browser technologies today.

  I've spent a bit of time looking at how to retrofit support for Shadow DOM and other aspects of web components into QuickUI. While that's led to some progress, I'm not entirely sure that that's the best approach. To ensure this is being done the best way, I'd like to try an alternative approach build from scratch directly on top of a custom element substrate. That experiment is Quetzal.

  There are a number of aspects of QuickUI that I believe are quite compelling, and which are either not easily supported in the proposed web standards, or appear under-represented in the current body of web components work. My goal in Quetzal is to explore whether those aspects of QuickUI have meaning in the world of web components, and what's the best way to bring those benefits forward. Some of those aspects of QuickUI I would very much like to see carried forward to the world of custom elements are:
  <ul>
    <li>A focus on subclassing as a means to achieve well-factored code, including a good separation of concerns. This includes an approach to populating the DOM in which an element class can <a href="http://quickui.org/docs/rendering.html">fill in properties and content slots defined by their base classes</a>.</li>
    <li>The ability to concisely define component appearance and behavior in script instead of markup. While the &lt;element&gt; syntax is part of the standard, and therefore a useful baseline, markup feels limiting compared to what's possible in script. A compact JavaScript object format can be at least as expressive, and possibly more expressive, than HTML.</li>
    <li>A convention for <a href="http://blog.quickui.org/2012/07/02/web-component-properties/">multiple, named, DOM-valued properties</a>.</li>
    <li>The ability to <a href="http://blog.quickui.org/2012/04/27/how-quickui-controls-use-code-to-specialize-the-handling-of-their-content-in-ways-that-might-not-be-supported-by-web-components/">run code when an element's contents change</a>.</li>
    <li>Syntactic sugar for quickly defining common types of component properties.</li>
    <li>Helper functions for tasks that come up often in UI component design. This includes, for example, a lightweight model by which an element can respond to changes in its size in order to perform custom layout.</li>
    <li>A significant library of well-designed web user interface components, including a large number of useful base classes that people can use directly as the starting point for their own work.</li>
  </ul>
  The Quetzal experiment seeks to preserve the above features, while still allowing a designer or developer to create new custom elements which can interoperate with custom elements created by any other means (e.g., as Polymer elements).

  Some early technical decisions for Quetzal:
  <ul>
    <li><span style="font-style:inherit;line-height:1.625;">I'm leaving jQuery out of Quetzal. I'll go into that decision in <a href="http://blog.quickui.org/2013/06/04/do-web-component-developers-still-need-jquery/">more detail later</a>, but the bottom line is that jQuery no longer seems absolutely necessary for web development. When QuickUI began back in 2007, jQuery was a vital cross-browser abstraction layer, but browsers have become a lot more consistent in the intervening years. If you look at the browsers currently supported by Polymer, the core DOM API appears consistent enough that it's not overly cumbersome to use directly. And while any custom element library should support jQuery use, it would be nice if jQuery weren't a requirement.</span></li>
    <li>For the time being, Quetzal is written in CoffeeScript rather than plain JavaScript. I find CoffeeScript much more expressive, more productive, and easier to think in than plain JavaScript. As with QuickUI (which is also written in CoffeeScript), Quetzal elements can of course be created and extended in plain JavaScript. Still, I recognize that using CoffeeScript limits one's audience. If Quetzal were to evolve to be a real open source project, I might feel the need to back-port it to JavaScript.</li>
    <li>Quetzal only relies on the lower-level platform.js library created by the Polymer project, rather than the higher-level polymer.js library or the (higher still) library of Polymer elements. The <a href="http://www.polymer-project.org/">Polymer home page</a> currently includes an architectural diagram illustrating the relationship between these two libraries. Quetzal builds on the lowest, red-colored platform.js level, not the higher yellow or green levels. In this regard, Quetzal is comparable to Polymer elements. Because both rely on web standards, the results should be easily interoperable. As a side effect, Quetzal should also help prove out the ability of someone other than Google to build a UI component framework on top of platform.js.</li>
    <li>I'm currently working and testing primarily in Chrome. At various points, I check to make sure Polymer is polyfilling everything correctly under other browsers, but at this early stage, it's likely stuff will appear wonky in other browsers.</li>
  </ul>
  Quetzal isn't ready for real use yet: it does just a few things at this stage, it's not document, it's buggy, it doesn't work cross-browser (even with polyfilled custom elements), etc. But I wanted to announce the experiment now so that I can follow up here with additional posts as I go along. Work on Quetzal is generating questions I want to ask others, and to provide context for those things it's going to be helpful to be able to reference Quetzal posts here and source code on GitHub. After exploring some ideas, Quetzal's useful life may come to an end, or its lessons might get folded back into QuickUI, or it may evolve into a library of Polymer elements.

  If you're interested in following along, subscribe to this blog, and/or follow me on <a href="https://twitter.com/JanMiksovsky">Twitter</a> and <a href="https://plus.google.com/118102862690539596548">Google+</a>.

  Cheers,
  Jan Miksovsky

2013-06-04.html: |
  ---
  title: "Do web component developers still need jQuery"
  date: 2013-06-04
  slug: do-web-component-developers-still-need-jquery
  originalUrl: http://blog.quickui.org/2013/06/04/do-web-component-developers-still-need-jquery/
  ---
  <em>I love you, jQuery. But maybe it's time we started spending some time apart.</em>

  Improvements in cross-browser feature set and compatibility are reducing the need for jQuery, but more importantly, it turns out that a component-based app needs very little jQuery to begin with. These insights led to one of the first decisions I hit in <a href="http://blog.quickui.org/2013/06/03/quetzal-an-experimental-translation-of-quickui-component-model-to-html-custom-elements/">starting Quetzal</a>: should it require jQuery? The answer, so far, is no.

  Since its inception in 2007, <a href="http://quickui.org">QuickUI</a> has relied on jQuery as a crucial browser abstraction layer. Without jQuery, QuickUI would have never have come to exist. However, the QuickUI runtime itself only uses a fairly small set of core jQuery functions, and modern browsers now deliver standards-based solutions for those situations. Moreover, I've noticed that, when building QuickUI component-based apps, component code tends to rarely require sophisticated jQuery.

  Meanwhile, the web has moved forward. The modern browsers — the latest Chrome, Safari, Mozilla, and Internet Explorer 10+ — are all much, much more consistent to develop for than browsers were six years ago. Glancing at pages on <a href="http://www.quirksmode.org/dom/w3c_core.html">QuirksMode</a>, one generally sees a see of green compliance, with most of the red markers of non-compliance for older versions of IE. And according to <a href="http://gs.statcounter.com/">StatCounter</a>, market shares for both IE 8 and 9 have now dropped below 10% (each), so it's plausible for mainstream organizations to justify ignoring them.

  Let's break down the things jQuery is good at, and consider how necessary are in a <em>web component-based</em> application (specifically) targeting the modern browsers:
  <ul>
    <li><strong>Handling an array of DOM objects.</strong> It's convenient to be able to apply a jQuery function or plugin to a jQuery object containing a collection of DOM elements. However, modern web languages (CoffeeScript, ES6, etc.) provide syntax for iterating over a collection, substantially reducing the need for a special library for this purpose. And, while jQuery's array model is easy to consume, it also makes writing components harder. QuickUI control classes inherit from jQuery, which means every QuickUI class method has to consider the possibility it's being applied to multiple objects at a time, not just one. In practice, that's been a consistent source of complexity and bugs.</li>
    <li><strong>Selectors.</strong> The standard querySelector and querySelectorAll functions provide a reasonable way to find matching elements. (I believe those functions were at least partially inspired by jQuery.) I've heard that jQuery's Sizzle engine provides more power than querySelector, but again, in a component-based app, you're rarely doing sophisticated searching of the DOM. In practice, when I'm writing an app with QuickUI components, I do very, very little searching of the DOM. Every QuickUI component already has its own reference to exactly the sub-elements it cares about. Polymer does something similar with <a href="http://www.polymer-project.org/polymer.html#automatic-node-finding">automatic node finding</a>. With such facilities in place, there's no need to grovel around in the DOM to find something you're looking for. In fact, with Shadow DOM, the things you're probably looking for <em>aren't even findable</em>. This is a good thing; encapsulation is preventing you from writing brittle code. Every time you do a $("#foo"), you're running the risk of picking up the wrong #foo — maybe not today, but tomorrow, when someone else adds a #foo element somewhere on the page. In Quetzal or Polymer, you never search for something like that; a component already has a direct reference (this.$.foo) to the element you want to manipulate. Unlike a DOM search, dereferencing is instantaneous and 100% reliable.</li>
    <li><strong>Traversing. </strong>Ditto. In practice, component subtrees  — that is, the set of elements managed <em>directly</em> by a component — just aren't that deep. A deep subtree is, in fact, often an indicator that component refactoring is in order. It's exactly analogous to the way a deeply-nested set of code blocks (conditionals, loops) within a single function usually indicates the function should be refactored. Nearly all the time a QuickUI component needs to traverse the DOM, it wants to iterate over its own set of children — which, as noted above, can now be easily done in a modern language with decent syntax.</li>
    <li><strong>DOM manipulation.</strong> As browsers have become more consistent in the semantics of DOM operations, jQuery feels less necessary here. And much of the jQuery DOM manipulations one sees are a means to set up all or part of the DOM. in jQuery, one often sees code like: "Find all the divs of class '.menuItem', and wrap them, stuff them, and wire them up so that they turn into menu items." The existence of web components provides a <em>much</em> better way to accomplish the same result. All the population can be done through custom elements that provide a template for their DOM. That said, jQuery does provide a useful collection of helper functions. For example, to me it feels easier to use jQuery's css() method, which can take a JavaScript object as a parameter, than use the raw DOM "style" property directly. Generally speaking, the DOM API feels more like an old school C API, while jQuery feels like a JavaScript API.</li>
    <li><strong>Function chaining.</strong> jQuery chaining lets you concisely apply a set of selector, traversal, and manipulation operations. In practice, all three of those types of operations come up less often in a web component-based app. In particular, one often sees long chains of jQuery function calls when populating the DOM, but a &lt;template&gt; is a cleaner way to do that declaratively. Over the years, in QuickUI apps, I've noticed that I use jQuery chaining less and less often, to the point where I only rarely take advantage of it today.</li>
    <li><strong>Events.</strong> Microsoft IE 9 finally added support for addEventListener, so that it's possible to wire up event handlers in a consistent way. I expect there are still many discrepancies lurking in the details — when each browser decides to fire an event, for example — that might prove tricky to work around without an abstraction layer like jQuery that can normalize behavior.</li>
    <li><strong>Effects.</strong> CSS transitions and transition events now provide an easy, cross-browser way to do many of the same effects jQuery was first noted for. For years, the jQuery home page used to have a simple demo which, when you clicked a button, made a new DOM element appear with a transition effect. Such effects are now easily achievable without jQuery.</li>
    <li><strong>Data.</strong> jQuery provided a useful $.data service to associate data with DOM elements, because a browser's garbage collector can get confused when DOM elements and JavaScript objects reference each other. The various browsers also had myriad bugs and inconsistencies with regard to extending DOM elements. So UI framework developers like those on Prototype <a href="http://perfectionkills.com/whats-wrong-with-extending-the-dom/">gave up on extending the DOM</a>. However, as far as I can tell from the way Polymer is tackling things, extending the DOM now appears to work (generally) as expected. So perhaps $.data is no longer necessary.</li>
    <li><strong>Ajax.</strong> I don't write a ton of Ajax code myself, so for argument's sake, let's stipulate that jQuery's Ajax wrappers are handier than directly working with XMLHttpRequest. In particular, jQuery's use of promises as a data type simplify the task of writing async code. Perhaps for the time being, this particular aspect of jQuery is worth using on its own. A proposed browser standard for <a href="http://dom.spec.whatwg.org/#futures">futures</a> may reduce that benefit, however.</li>
    <li><strong>Plugins.</strong> Many, many of the jQuery plugins that exist today essentially create component-like things. These plugins effectively constitute a DOM template with some packaged behavior. I'd argue that a web component is a clearer, more maintainable way to achieve the same result. Encapsulation, in particular, is a huge advance to providing robust components. Moreover, many other uses for plugins could now be achieved by extending DOM elements directly.</li>
  </ul>
  Generally speaking, in a component-based app, you want to give each component the responsibility for managing its own appearance and behavior. You don't want code walking all over the DOM tree and mucking around with things that aren't its direct responsibility. Instead, you talk to the component managing the part of the DOM you care about, and ask that <em>component</em> to manipulate the elements it directly owns. In classic object-oriented programming terms, this is an application of the <a href="http://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter</a>.

  In practice, compartmentalizing things that way leaves each component doing very simple manipulations on a comparatively small set of elements: instantiating a new element; iterating over its own children; applying or removing a style; etc. If a component wants to do something more sophisticated to its internals, more likely than not the component should delegate that operation to one of its own sub-components. The component's own need to search is limited, reducing the need for a powerful selector/traversal engine. And, given a reasonably good programming language, simple DOM manipulations can be performed effectively — and with better performance — by directly accessing the DOM API.

  I'm no cross-browser DOM API expert, and I've only just started to try to do things without jQuery. I could easily hit a landmine tomorrow, tripping upon some cross-browser nastiness I've been blithely unaware of, which jQuery for years has been invisibly and reliably been protecting me from. That said, work on Quetzal is progressing fairly smoothly without jQuery, and a week or two into this project, I'm not missing most of jQuery. It <em>would</em> be nice to have a much smaller library of helper functions which present a more JavaScript-flavored approach to the DOM API, as in jQuery's css(), mentioned above.

  From one standpoint, you could say I've just traded one browser abstraction layer (jQuery) for another (Polymer's platform.js). However, platform.js feels like a pretty different animal than jQuery:
  <ul>
    <li>The beauty of Polymer's approach of polyfilling forthcoming web standards in older browsers is that you can write code against the abstraction layer today that should invisibly start working against native implementations where and when those exist. It's still early, and that promise remains to be proven — but that's a very compelling promise.</li>
    <li>Those future standards mean you're working with facilities that someday every other developer will have (whether they want them or not). You're writing code on top of a library that could get smaller over time, not larger.</li>
    <li>The other difference with platform.js, as far as today's web component developers are concerned, is that it's really the only game in town. Unless you have the luxury of targeting the latest release of Chrome, you'll need to use platform.js (or the complete polymer.js) to run on other browsers.</li>
    <li>If one's goal is to write components that many people will use, it makes sense to reduce the number of additional dependencies. If jQuery's not required, then the lack of that dependency to some degree facilitates sharing.</li>
  </ul>
  We'll see how the Quetzal experiment evolves, but so far, writing directly to the DOM API is working out okay.

  <em>So, jQuery, maybe we should spend some time apart.<em> <em>Maybe we should see some other people. </em>It's not you — it's me!</em> Don't worry; I might miss you terribly and come running back. Or maybe we'll just be friends.</em>

  <em>It's okay. We'll always have IE6.</em>

2013-06-11.html: |
  ---
  title: "Puzzle: Define HTML custom element subclasses that can fill in base class insertion points"
  date: 2013-06-11
  slug: puzzle-define-html-custom-element-subclasses-that-can-fill-in-base-class-insertion-points
  originalUrl: http://blog.quickui.org/2013/06/11/puzzle-define-html-custom-element-subclasses-that-can-fill-in-base-class-insertion-points/
  ---
  This post presents a little web component architectural puzzle which I've come across in the early stages of creating <a href="http://janmiksovsky.github.io/quetzal">Quetzal</a>. The puzzle deals with how Quetzal should best deliver an important component service on an HTML custom element substrate, and relates specifically to subclassing semantics. Any suggestions or comments would be much appreciated.
  <h1>Background on the puzzle</h1>
  Quetzal is an attempt to deliver key features of the QuickUI component model in HTML custom elements. One such feature is that an element subclass should be able to easily populate a slot (insertion points, in HTML parlance) defined by a base class. In practice, there are many situations in which you want to be able to say, "This new UI component should be just like that existing UI component, only with some stuff pre-filled in." For example:
  <ul>
    <li>The QuickUI documentation presents a <a href="http://quickui.org/docs/rendering.html">simple page template example</a> in which classes in a small page template hierarchy fill in specific bits of their parents classes.</li>
    <li>A <a href="http://quickui.org/catalog/DateComboBox">DateComboBox</a> fills in the popup portion of a <a href="http://quickui.org/catalog/ComboBox">ComboBox</a>, which in turn is filling the content portion of a <a href="http://quickui.org/catalog/PopupSource">PopupSource</a>. This same facility is also used throughout the QuickUI Catalog. Moreover, it is used in many QuickUI apps in which a stock Catalog component is specialized for the app's context.</li>
    <li>Along those same lines, this same issue should crop up in any organization that tries to create a library of standard components which implement the organization's visual design language. Suppose your site's designer has created a cool button class as an HTML custom element, and you have used that to create an Add to Cart button. You write some script so the button can show <em>inside the button</em> the existing number of items in a customer's online shopping cart (to the right of the button label, say). You now want to package up the Add to Cart button so that it can be used as a component in its own right. For flexibility, you want the button's text label to vary in places.</li>
  </ul>
  Well-defined subclassing semantics are essential for creating a UI component library with a good separation of concerns. If you look at the class hierarchy depicted for DateComboBox (above), you'll get a sense of the degree to which it's possible to portion out specific roles to a small constellation of classes, such that each class can focus on just doing one thing really well.

  I'm hoping that it is possible to take advantage of such subclassing semantics in HTML custom elements — but it's not proving to be particularly easy.
  <h1>The puzzle</h1>
  The puzzle is to come up with an architecture for custom element subclasses that meets the following design criteria:
  <ol>
    <li>An instance of a subclass is a proper instance of its base class. All the normal JavaScript stuff should work: property/method access should go up the prototype chain, and a subclass instance should report that it is an "instanceof" the base class. By default, the HTML &lt;element&gt; syntax permits an "extends" attribute to identify a base class, but a purely script-based solution that sets up the class hierarchy correctly is equally valid.</li>
    <li>A subclass can put stuff into an insertion point defined by the base class. That is, the subclass can fill in a slot (or slots) defined by a base class. In turn, the subclass should be able to redefine such an insertion point so that the subclass itself can be subclassed.</li>
    <li>Unless overridden, all base class behavior should function properly in an instance of the subclass. E.g., if the base class wires up an event handler, then this works as expected for subclass instances too.</li>
    <li>Base class properties/methods can be overridden by the subclass. A subclass' property/method implementation should be able to invoke the base class' implementation by whatever language means are necessary. (CoffeeScript provides sugar for this; plain JavaScript developers have alternate ways of achieving the same result.)</li>
    <li>The base class can be any HTML custom element class; the base class author shouldn't<em> </em>have to do special work <em>a priori</em> to enable this kind of subclassing. This ensures a Quetzal author can always use someone else's element class as a base class — even if that other person has never heard of Quetzal.</li>
  </ol>
  A successful solution needs to meet all five of these criteria. So far, the approaches I've tried can satisfy at most four at a time.
  <h1>Example</h1>
  Let's walk through a example from the small set of custom elements currently shown on the <a href="http://janmiksovsky.github.io/quetzal">Quetzal home page</a>. This set includes a base element class called quetzal-button that shows its content inside a button, and another element class called icon-button which adds an icon to the plain-button content. For clarity, here let's just call that base class plain-button instead of quetzal-button, since the following source won't actually involve Quetzal. In any event, we want markup like this:
  <pre>&lt;plain-button&gt;Plain button&lt;/plain-button&gt;
  &lt;icon-button icon="document.png"&gt;Icon button&lt;/icon-button&gt;</pre>
  … to produce something like this:

  <img title="buttons.png" alt="Buttons" src="http://quickui.files.wordpress.com/2013/06/buttons.png" width="219" height="34" border="0" />

  Where icon-button is reusing all the styling and behavior from plain-button; it's <em>not</em> duplicating the styling and behavior. The challenge is to create the icon-button element so it both inherits (in the class sense) from plain-button <em>and</em> extends the visual representation of plain-button.
  <h1>A partial solution to filling in base class insertion points</h1>
  The first challenge is: how can icon-button add elements to the content shown by plain-button? Some approaches:
  <ol>
    <li>We could try to apply the template for <em>both</em> plain-button and icon-button to the same host element. The Shadow DOM spec supports <a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#multiple-shadow-trees">multiple shadow trees attached to the same host</a>. This feature alone is insufficient for the above example. Unless one shadow tree takes care to incorporate the other somehow, the most recently-added shadow subtree wins. If plain-button renders last, we get a button but no icon; if icon-button renders last, we get an icon but no button.</li>
    <li>We can include a &lt;shadow&gt; element in the template for icon-button, and ensure plain-button renders its shadow subtree first. The &lt;shadow&gt; element allows icon-button to effectively include the representation for plain-button. Unfortunately, this inclusion effectively <em>wraps</em> the base representation, rather than filling it in. An icon-button does get a button and an icon, but the icon and content render <em>outside</em> an empty button: <img title="shadow.png" alt="shadow" src="http://quickui.files.wordpress.com/2013/06/shadow.png" width="115" height="20" border="0" /></li>
    <li>We can have icon-button create an instance of its own base class, then have that instance contain the icon and the icon-button's own content. (This approach is based on a suggestion from Shadow DOM spec author Dimitri Glazkov.)</li>
  </ol>
  Approach #3 does what we want from a strictly visual perspective. (Behavior is a separate matter.) The source for a Polymer element version of this approach looks something like:
  <pre>&lt;element name="plain-button" extends="button"&gt;
      &lt;template&gt;
          &lt;button&gt;
              &lt;content&gt;&lt;/content&gt;
          &lt;/button&gt;
      &lt;/template&gt;
      …
  &lt;/element&gt;

  &lt;element name="icon-button" extends="plain-button" attributes="icon"&gt;
      &lt;template&gt;
          &lt;plain-button&gt;
              &lt;img src="{{icon}}"&gt;
              &lt;content&gt;&lt;/content&gt;
          &lt;/plain-button&gt;
      &lt;/template&gt;
      …
  &lt;/element&gt;</pre>
  See a <a href="http://jsbin.com/unutay/1/edit">live example of this</a>. It should work in most browsers, but use Chrome if you want to see it working with real Shadow DOM. (Note: a <a href="https://code.google.com/p/chromium/issues/detail?id=244869">Chrome bug</a> prevents the buttons from responding correctly to mouse interactions. The buttons do receive mouse events, but for now it just doesn't look that way.)

  If you open the example and inspect it in Chrome dev tools, you'll see that an icon-button has a shadow subtree containing a plain-button; the plain-button contains its own shadow subtree. Content of an &lt;icon-button&gt; element is therefore distributed <em>twice</em>: once into the &lt;plain-button&gt; element, and then again into the native &lt;button&gt; element. The ability of Shadow DOM to distribute nodes multiple times is called <a href="http://www.w3.org/TR/shadow-dom/#reprojection">reprojection</a>. (Or, at least, it meets the definition of reprojection as I understand it: "when an insertion point is a child node of another shadow host".)
  <h1><strong>Inheritance versus containment</strong></h1>
  Unfortunately, while this approach looks right, it doesn't behave quite right. An icon-button here is not only an instance of plain-button, it also contains a plain-button. That's problematic.
  <ol>
    <li>When icon-button instantiates its inner plain-button, the inner button has no way to know its relationship to icon-button. Among other things, this means icon-button can't easily override behavior defined by plain-button (one of the design criteria above). In the JS Bin example, you can turn on the Console pane to see debug output. The plain-button element class defines a readyCallback (in Polymer, "ready") that invokes a base class method called log(). The icon-button class overrides that log() method, but because the inner plain-button is just that — a plain-button — its readyCallback will invoke the base plain-button implementation of log() instead of icon-button's specialized log() implementation. Running the demo invokes log() four times, when: 1) creating an instance of plain-button to use as the prototype for icon-button, 2) creating the visible plain-button with text "Plain button", 3) creating the inner plain-button used by the visible icon-button, and 4) creating the visible icon-button with text "Icon button". It's #3 and #4 together that are the problem: what we really wanted to do is invoke icon-button's log() implementation once.</li>
    <li>Automatic element references (a la Polymer, and also in Quetzal) aren't inherited by default. If plain-button defines an element with id #foo, then plain-button methods can access that element via the automatic reference this.$.foo. Similarly, we want an icon-button to have access to the same reference this.$.foo defined by the base class. (Or, at least, we can debate whether such automatic references should be treated as "private" or "protected", but it seems to me that "protected" would be useful.) It's possible to work around this particular issue for a known set of frameworks — that is, Quetzal could workaround this problem for its own classes, and perhaps for those defined by Polymer — but it wouldn't work in the general case of an unknown framework.</li>
    <li>It's easy to end up in situations where both icon-button and plain-button are duplicating work. Suppose an icon-button method invokes a super-method of the same name defined by plain-button, and suppose the base implementation of that method performs expensive work or obtains a reference to some resource. When the inner plain-button is instantiated, it might do that work — and then the same work or allocation might be repeated by the outer icon-button when it invokes the super-method. Conventions could be established to avoid this, but it would complicate otherwise simple situations, and again make it hard to use subclass elements from other frameworks.</li>
    <li>As a common case of the above point, if the inner plain-button wires up an event handler, then it's easy to end up in situations where the event is bound by both the inner plain-button and the outer icon-button. If the event bubbles up from something inside plain-button (a click on the button, say), you would end up handling the same event twice.</li>
  </ol>
  We could try to simplify things by just <em>containing</em> an plain-button, and not deriving from it. This forces us to give up one of the original design criteria outlined above: an instance of icon-button wouldn't actually appear to be an "instanceof" plain-button. Moreover, if plain-button defined some attributes ("disabled", say), icon-button would have to explicitly handle those too and forward their implementation to the inner plain-button.

  We could have icon-button create a placeholder element (a &lt;div&gt;, say), create a shadow root for it, and populate that root with a copy of plain-button's template but <em>without</em> actually instantiating that inner element as a real, live plain-button. This is the approach that Quetzal currently uses. It solves a number of problems, but is dependent on knowing how a given base element class works. Quetzal reaches into the base class' implementation to obtain its template and then clones it, which might not be possible with other frameworks. This violates one of the design criteria above.

  We could create a temporary instance of plain-button elsewhere, then clone just its contents into the icon-button instance. This avoids requiring detailed knowledge of what the base class is doing. But it could also result in subtle problems. E.g., the base class might not be expecting to have to serialize all its state into its shadow subtree, in which case the cloned content might not represent a coherent instance of the base class.
  <h1>Looking for suggestions</h1>
  This post is effectively a form of <a href="http://en.wikipedia.org/wiki/Rubber_duck_debugging">rubber duck debugging</a>. The simple act of writing this up has forced me to better understand the problem, and led to consideration of alternate lines of attack. The puzzle remains unsolved, however. Given my understanding of custom elements, and the design criteria for the puzzle above, I'm not sure whether a solution exists.

  It's theoretically possible I've hit some limit in the expressiveness permitted to custom elements in their current state. Perhaps that limitation could be addressed. If not, I'd  have to write off a big chunk of the solutions used by the QuickUI Catalog and QuickUI apps, and find alternate ways of meeting the same needs.

  I'm hoping, however, that I'm just missing something. If you have some passing familiarity with HTML custom elements and Shadow DOM, and have ideas about how to approach this problem within the existing technology, I'd love to hear them!

2013-07-17.html: |
  ---
  title: "Quetzal, take 2: creating general-purpose UI components as Polymer elements"
  date: 2013-07-17
  slug: quetzal-take-2-creating-general-purpose-ui-components-as-polymer-elements
  originalUrl: http://blog.quickui.org/2013/07/17/quetzal-take-2-creating-general-purpose-ui-components-as-polymer-elements/
  ---
  Just an update to the experimental <a href="http://janmiksovsky.github.io/quetzal/">Quetzal project</a> I posted about last month. I've learned quite a bit, and have changed course on two significant points, and thought I'd share a bit about my experiences with others who might be contemplating the creation of a framework or UI component library on top of web components.

  <strong>A limitation of the current web component architecture</strong>

  So far, the greatest challenge in replicating the range of expression in QuickUI's UI components has been the inability to easily <a href="http://blog.quickui.org/2013/06/11/puzzle-define-html-custom-element-subclasses-that-can-fill-in-base-class-insertion-points/">define HTML custom element subclasses that can fill in base class insertion points</a>. To their credit, Google's Blink (rendering engine) and Polymer (web component framework) teams have been responsive on that point. In response to a Polymer discussion board thread related to that post, a bug has been filed to allow one to <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=22344">distribute content nodes into a &lt;shadow&gt; insertion point</a>. Unless you're already experimenting with Shadow DOM, this entire issue undoubtedly seems quite arcane, but rest assured, fixing this one problem would open up a lot of important new territory.

  I'm sincerely hoping this proposal is adopted. In the meantime, I've been using a workaround to simulate the effects of that proposal. That unfortunately <a href="https://github.com/Polymer/polymer/issues/203">broke in a recent Polymer update</a>, but such setbacks are to be expected when building on shifting sand.

  <strong>Trying Polymer elements</strong>

  I've spent some time experimenting with Polymer's own element layer, and last month decided to try adopting it. My first cut at creating custom elements for Quetzal was based directly on Polymer's lower levels, which take care of polyfilling (emulating) various web component standards. I'm now trying to use the higher-level Polymer elements layer, which provides a richer framework for creating custom elements, and adds a number of features to simplify common component tasks. These features are not part of any web component standard, but by virtue of being done by Google, will nevertheless probably become a common feature of the web component landscape.

  There are still a number of QuickUI features that have no parallel in standard web components or Polymer elements, but most of those missing features appear to be things which I could implement on top of Polymer elements. For example, a &lt;quetzal-element&gt; base class could provide those missing features, making it easy for new element classes to obtain them. Aside from the critical limitation mentioned above, it now appears to me that most (hopefully, all) of QuickUI could likely be implemented as Polymer elements.

  With that change, the latest Quetzal iteration recreates a handful of <a href="http://quickui.org/catalog/">QuickUI Catalog</a> elements as Polymer elements. So far, this approach feels acceptable, and it would obviously be a big advantage to leave most of the heavy lifting to the Polymer team, and focus on actually creating new custom elements.

  Some notes on switching to Polymer elements:
  <ul>
    <li>Using HTML to declare an element template feels quite verbose and cumbersome compared to QuickUI's use of CoffeeScript's concise JavaScript object format. If you haven't tried CoffeeScript, it improves over plain JavaScript object syntax by using indentation instead of requiring tons of curly braces and commas. Using HTML feels comparatively ponderous and noisy, and to me all that noise makes custom element source files somewhat less legible. Still, HTML <em>is</em> the lingua franca of the web, and using a standard confers a huge advantage over a proprietary format, however efficient it might be. At some point, the Polymer team says they'll support an imperative JavaScript means to define custom elements, but for now I'm guessing the vast majority of custom elements will use HTML, so that's what I want to try.</li>
    <li>Speaking of standard formats, one aspect of Polymer that's recently changed is that the top-level tag used to define a new element is now &lt;polymer-element&gt;, instead of the standard &lt;element&gt;. While Polymer elements are now just as locked into the Polymer framework as before, this change makes it feel like I'm no longer using a web standard — it feels like just another proprietary UI framework that happens to use XML/HTML as its format. It's surprising what a difference this small change makes. Using &lt;element&gt; simply <em>felt</em> better.</li>
  </ul>
  <strong>Going back to plain JavaScript</strong>

  Switching the top-level component container to HTML instead of script has also prompted me to give up CoffeeScript, at least for now. I actually tried using a combination of CoffeeScript and HTML, but it felt like I was working against the grain, and I ended up giving up on that approach.

  Going from CoffeeScript back to plain JavaScript is an excruciating experience. Oliver Wendell Holmes said, "Man's mind, once stretched by a new idea, never regains its original dimensions." I think the programming language analogue here is: once your brain has been expanded by a language that lets you more clearly express your intensions, trying to cram your brain back into the tiny box of a less expressive language is unbelievably painful.

  Every single time I have to write a JavaScript loop instead of a CoffeeScript list comprehension, or type "function() {}.bind(this)" instead of just "=&gt;", I physically wince a bit. JavaScript just feels gross, it looks gross, it <em>is</em> gross.

  That said, JavaScript is the standard. One thing I've learned from QuickUI is that if you're trying to build a community around a common library, creating that library in a programming language with a narrow audience dramatically limits the rate at which you can grow. One commenter named "jokester" offered on my original Quetzal post: "I’ll unfortunately not contribute to a project coded in CoffeeScript." Regardless of the advantages I believe CoffeeScript offers to developers, I'd rather allow orders of magnitude more people to contribute in the standard JavaScript language they're already proficient in.

  Anyway, that's about the state of things. This Quetzal project is still just an experiment, and doesn't do much useful yet, but it's proving a good way to learn.

2013-08-26.html: |
  ---
  title: "Polymer list box and combo box elements"
  date: 2013-08-26
  slug: polymer-list-box-and-combo-box-elements
  originalUrl: http://blog.quickui.org/2013/08/26/polymer-list-box-and-combo-box-elements/
  ---
  The updated <a href="http://janmiksovsky.github.io/quetzal/">Quetzal</a> home page shows off a handful of new elements ported from QuickUI:
  <ul>
    <li>A quetzal-list-box element that presents its children as items in a list. This makes it easy to give any collection of DOM elements the semantics of a single-selection list. The actual tracking of the selection is handled with Polymer's own polymer-selector element. On top of this, the Quetzal list box adds keyboard navigation: the user can navigate the list using the Up/Down arrow keys, as well as Home/End and Page Up/Page Down. This keyboard navigation follows the Microsoft Windows model, in which navigation keys move the selection, which in turn forces the list's scroll position to update to show the selected item. This makes it faster to select an item with the keyboard. (In Mac OS X, paging up and down does not update the selection.)</li>
    <li>A quetzal-combo-box element ties together a text input element, a popup, and a button to invoke or dismiss the popup. See this post on <a href="http://miksovsky.blogs.com/flowstate/2011/10/listcombobox.html">the original QuickUI combo box</a> for details on combo box behavior. Again, a key feature here is keyboard support: the Down key invokes the popup (if it's not already open), and the Escape key dismisses it. Another feature (inherited from the popup-source element) is positioning the popup above or below the text area as room allows. This combo box element doesn't provide a specific popup UI. Rather, it's intended to be used as a base class for custom combo box elements.</li>
    <li>A quetzal-list-combo-box element combines the two above elements to create a typical combo box which presents choices as a dropdown list box. This includes standard auto-complete behavior. In many situations, a combo box like this is often a better UI solution than a plain text box with auto-complete: the user has a clearly visible button which can be used to invoke the complete list of choices. This is more discoverable than requiring the user to begin typing to see what the possible choices are. The auto-complete behavior matches against the textContent of the elements' children, so the list items can be any type of item that has meaningful textContent. The sample shown uses a custom element that shows a color swatch next to a color name; typing some text will auto-complete against the set of color names.</li>
  </ul>
  These elements still need more work. For example, the combo box needs a stock mobile variant in which the element can fill the screen when making a selection to provide bigger hit targets and maximize the number of visible list choices. Also, at the moment simply tapping a list box element causes the Android Chrome browser to crash. This makes it somewhat hard to debug. :( Nevertheless, I think these element demonstrate that a good set of UI base classes will make it much easier to create custom UI designs as web components take hold.

2013-11-08.html: |
  ---
  title: "Filling in base class slots with the awesome new capability of the shadow element"
  date: 2013-11-08
  slug: filling-slots-in-shadow
  originalUrl: http://blog.quickui.org/2013/11/08/filling-slots-in-shadow/
  ---
  In a <a href="http://blog.quickui.org/2013/06/11/puzzle-define-html-custom-element-subclasses-that-can-fill-in-base-class-insertion-points/">post a few months back</a>, I discussed how custom elements needed an easy way to fill in slots defined by their base classes. The capable folks on Google’s Blink team have now fixed this problem with a small but critical Shadow DOM change, and I wanted to take a moment to walk through an example of how the feature works and explain why this is so cool.

  What does “filling in a slot” mean, and why does it matter? The crux of the issue, for us to be able to share web components, I need to be able to create a new web component that defines some, but not all, of its appearance. I need be able to define certain places that you can fill in with your content. Those are the slots: points of visible user interface extensibility.

  <b>Example: a series of page templates</b>

  The post linked above offers a simple button example, but let’s walk through a more realistic example using a series of page templates. (If you have Google Chrome Canary installed, you can follow along with <a href="http://jsbin.com/uJuxAzi/1/edit">a live demo</a>.) These sample templates will span a range of general-purpose to very specific. <span style="font-style:inherit;line-height:1.625;">For the sake of clarity, the examples are overly simple, and are intended just to convey a sense of how such templates might be used to build a simple online store app. The same principles shown here could easily be extended to arbitrarily complex interfaces.</span>

  <img alt="Page Template 1" src="http://quickui.files.wordpress.com/2013/11/page-template-1.png" />
  <em>A page-with-toolbar</em>

  <span style="font-style:inherit;line-height:1.625;">We start with a completely general-purpose &lt;page-with-toolbar&gt; element that defines a page with a toolbar. For the sake of argument, let’s suppose there’s something fancy about the presentation here — perhaps the toolbar starts out at one size, and then, as the user scrolls, the toolbar becomes smaller and permanently docked at the top of the page. Regardless of what exactly makes this interesting, let’s assume that interesting stuff entails web ninja tricks the average designer or developer doesn’t have the time to learn or implement for themselves. Significantly, some aspect of the toolbar behavior requires real code, not just CSS styling.This user interface pattern is completely general-purpose, so perhaps this template is found in an online library of general-purpose web components. The key extensibility feature here is that the element defines two slots which consumers of the &lt;page-with-toolbar&gt; element can fill in: a toolbar slot at the top, and a main content slot.</span>

  <img alt="Page Template 2" src="http://quickui.files.wordpress.com/2013/11/page-template-2.png" />
  <em>A store-page partially fills in a page-with-toolbar</em>

  <span style="font-style:inherit;line-height:1.625;">This second image shows a &lt;store-page&gt; element that forms the standard base for all pages in our hypothetical online store. This element subclasses (extends) the general-purpose &lt;page-with-toolbar&gt; element above, so it automatically picks up the structure defined by that element and the fancy toolbar behavior. The designer of the store app can fill in some of that structure with elements that should be visible on every page in the store, such as a Home button and the story name. That is, the designer can partially fill in the slots defined by the base class: after adding the standard elements they want on every page, they can define new slots that can be filled in by instances or subclasses. The designer can also add visual styling and any behavior that should be available on every page in the app. When complete, this page both extends the above element, and is itself extensible. The element is specific to this company, but could be used by any team at the company working on their online store.</span>

  <img alt="Page Template 3" src="http://quickui.files.wordpress.com/2013/11/page-template-3.png" />
  <em>A product-page partially fills a store-page</em>

  The third image shows a &lt;product-page&gt; element. This extends the &lt;store-page&gt; element above to create a template for any page specifically in the app’s Products area. It fills in the toolbar slot with buttons that are only available on product pages. It also partially fills in the main content slot with a header for the product name. Finally, it adds any styling and behavior shared only by pages in the Products area. This product page element is still extensible, but an increasing portion of its interface and behavior are constrained.

  <img alt="Page Template 4" src="http://quickui.files.wordpress.com/2013/11/page-template-4.png" />
  <em>A completed instance of product-page</em>

  Finally, we have an example of a filled-in &lt;product-page&gt; element. Presumably the app fills in the page by obtaining product data and used that to populate various elements on the page (e.g., using data binding). Now the whole page has been filled in.

  By factoring our app’s design this way, we’ve created a good separation of concerns. The &lt;page-with-toolbar&gt; element doesn’t have to know anything about online stores. Conversely, the &lt;store-page&gt; element doesn’t have to know anything fancy toolbar behavior. The &lt;product-page&gt; designers don’t even need to know where the toolbar behavior comes from — all they need to know is that they get it for free. If the team at the company that owns the &lt;store-page&gt; element later decides to change the toolbar behavior, they can do so without the people who own the &lt;product-page&gt; element needing to do anything.

  <b>How does this work?</b>

  Until recently, it wasn’t possible for a custom element to fill in slots defined by a base class this way. An element’s template could contain a &lt;shadow&gt; element to ask its base class to render its stuff, but there wasn’t an easy way to pass content to the base class. Over the past couple of months, the Blink folks working on Shadow DOM features have just addressed this shortcoming with a new feature in the <a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html">Shadow DOM spec</a> and its Blink implementation. Technically speaking, the spec now allows a custom element to distribute nodes into a &lt;shadow&gt; insertion point and then reproject those nodes into an older shadow root.

  To see an example of how this works, see <a href="http://jsbin.com/uJuxAzi/1/edit">the live demo</a>. At the time of this post, you’ll need to use <a href="https://www.google.com/intl/en/chrome/browser/canary.html">Google Canary</a>. You’ll also need to open chrome://flags and check "Enable experimental Web Platform features". But this feature will likely make its way into production Chrome in the not-so-distant future, and get polyfilled by the Polymer project for other browsers.

  You can look through the code for the complete story, but the gist is this: if your element puts stuff inside a &lt;shadow&gt;, then that stuff will be passed to the base class as content. In our &lt;page-with-toolbar&gt; example element, the template contains a bit for the toolbar that looks like this:
  <pre>&lt;polymer-element name=”page-with-toolbar”&gt;
  &lt;template&gt;
    …
    &lt;div id=”toolbar”&gt;
      &lt;content select=”.toolbar”&gt;&lt;/content&gt;
    &lt;/div&gt;
    …
  &lt;/template&gt;
  &lt;/polymer-element&gt;</pre>
  That &lt;content select=”.toolbar”&gt; bit creates a slot that can be filled in by instances — or by subclasses. When our &lt;store-page&gt; element subclasses &lt;page-with-toolbar&gt;, it fills in that slot:
  <pre>&lt;polymer-element name=”store-page” extends=”page-with-toolbar”&gt;
  &lt;template&gt;
    &lt;shadow&gt;
      &lt;span class=”toolbar”&gt;
        &lt;button&gt;Home&lt;/button&gt;
        &lt;content select=”.toolbar”&gt;&lt;/content&gt;
      &lt;/span&gt;
      …
    &lt;/shadow&gt;
  &lt;/template&gt;
  &lt;/polymer-element&gt;</pre>
  Everything inside the store-page’s &lt;shadow&gt; will look to the page-with-toolbar base class like regular content. The page-with-toolbar’s toolbar slot will grab the span with class=”toolbar”, so the store-page’s Home button ends up in the toolbar. This lets store-page fill in the toolbar slot defined by page-with-toolbar.

  So that store-page itself can be extended, it in turn redefines that toolbar slot. Any toolbar buttons defined by subclasses of store-page (like the Add to Cart and Buy Now buttons in our product-page example) will get picked up by store-page’s toolbar slot, which is nestled inside page-with-toolbar’s toolbar slot.

  <b>Conclusion</b>

  Sometimes tiny differences in fundamental features, like this refinement to the &lt;shadow&gt; behavior, can open up new realms of possibility. While it doesn’t look like much, when combined with subclassing, you’ve just been given a powerful new tool for creating custom web elements. You’ll be able to create a wide range of new general-purpose elements that can be filled in by other people to suit their needs, and you’ll be able to fill in general-purpose elements created by others to suit your own needs. This is a huge step towards a <a href="http://miksovsky.blogs.com/flowstate/2012/03/snapping-together-a-skyscraper.html">vibrant ecosystem of web user interface components</a>.

  <em>Beyond the expanded capabilities enabled here, I’m personally excited to see this change because I’ve been advocating for it for so long. I made a pitch for this on a visit to Google back in May 2012, and have promoted the idea in various forums since then. Other people like Scott Miles at Google also lobbied for the same thing. Special thanks are owed to Scott and to Dominic Cooney for contributing their own weight behind this idea and building the momentum required to make it happen; to Blink developer Hayato Ito for his work updating the spec and implementing the feature in Blink; and to Dimitri Glazkov for his careful oversight of the Shadow DOM spec. This is one spec change that was totally worth the trouble!</em>

2013-11-26.html: |
  ---
  title: "Ending active development of QuickUI"
  date: 2013-11-26
  slug: ending-active-development-of-quickui
  originalUrl: http://blog.quickui.org/2013/11/26/ending-active-development-of-quickui/
  ---
  I’ve decided to end further investment in the development of the QuickUI web user interface framework.

  I’ve spent the past half-year experimentally porting various QuickUI components to HTML custom elements under the rubric of a project called <a href="http://janmiksovsky.github.io/quetzal/">Quetzal</a>. That project makes use of Google’s <a href="http://www.polymer-project.org/">Polymer</a> project, which supports the deployment of web components to mainstream browsers. While the Quetzal element collection doesn’t yet offer the complete set of QuickUI components, and working on top of Polymer has been shaky at times, Polymer is becoming good enough for real use, and the advantages of building with web standards will quickly outweigh any proprietary advantages which QuickUI could offer.

  I started QuickUI a number of years ago because it seemed clear to me that a component-oriented approach to UI design and development would let you create better and more maintainable user experiences. <span style="font-style:inherit;line-height:1.625;">I didn't see anyone else working on that in an open way, and so began my own effort to make progress in that area.</span>

  The current wave of web component standards embody many of the ideas I was pursuing in QuickUI. For fun, I just dug up from my notes the earliest source code I could find for the component markup language I thought would be useful for creating web components. Here's sample QuickUI markup I wrote at the very beginning, probably late 2007:
  <pre>&lt;control name="taskPage" arguments="name pageTip content"&gt;
    &lt;style&gt;
      h1 { font-face: Arial; }
    &lt;/style&gt;
    &lt;script&gt;
    function foo() { }
    &lt;/script&gt;
    &lt;template&gt;
      &lt;div ...&gt;
        &lt;h1&gt;%name%&lt;/h1&gt;
        &lt;p class="pageTip"&gt;%pageTip%&lt;/p&gt;
        &lt;div id="#content"&gt;
          %content%
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/template&gt;
  &lt;/control&gt;</pre>
  Here's the corresponding source code in late 2013 for the same custom element in Polymer:
  <pre>&lt;polymer-element name="task-page" attributes="name pageTip"&gt;
    &lt;script&gt;
    function foo() { }
    &lt;/script&gt;
    &lt;template&gt;
      &lt;style&gt;
        h1 { font-face: Arial; }
      &lt;/style&gt;
      &lt;div ...&gt;
        &lt;h1&gt;{{name}}&lt;/h1&gt;
        &lt;p class="pageTip"&gt;{{pageTip}}&lt;/p&gt;
        &lt;div id="#content"&gt;
          &lt;content&gt;&lt;/content&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/template&gt;
  &lt;/polymer-element&gt;</pre>
  Aside from minor syntactic differences (curly braces are in vogue now instead of percent signs; "attributes" instead of "arguments"; the style tag needs to be inside the template instead of outside; the element name requires a hyphen), the source code is nearly identical. In other words, the source code I wanted to be able to write in 2007 is essentially the source code I can now write today. Hooray for the open web!

  <span style="font-style:inherit;line-height:1.625;">Going forward I’ll be using web components for my own work rather than QuickUI. If you have been using QuickUI or were interested in QuickUI, I would encourage you to look at adopting web components instead, either through the Polymer project or through similar projects such as Mozilla’s </span><a style="font-style:inherit;line-height:1.625;" href="http://x-tags.org/">x-tags</a><span style="font-style:inherit;line-height:1.625;">.</span>

  I’ll continue to keep the quickui.org site live for the indefinite future. In particular, for the time being I’ll continue to use this blog to post thoughts on developing user interfaces, with a focus on using web components.

  To those of you that used QuickUI or provided feedback on it, I’d like to offer my warm thanks for all of your support.

  Best,
  Jan Miksovsky

2013-12-01.html: |
  ---
  title: "Some lessons from an open source project that never gained critical mass"
  date: 2013-12-01
  slug: some-lessons-from-an-open-source-project-that-never-gained-critical-mass
  originalUrl: http://blog.quickui.org/2013/12/01/some-lessons-from-an-open-source-project-that-never-gained-critical-mass/
  ---
  I recently announced that I was <a href="http://blog.quickui.org/2013/11/26/ending-active-development-of-quickui/">halting development on QuickUI</a>, and thought it would be a good idea to do a little post-mortem before moving on.

  The good side: As a framework for web application UI development, QuickUI measured up to its design goals. It was useful for creating complex application UIs with a good separation of concerns between UI components. The core framework was highly reliable with a fairly tight abstraction and acceptable performance. QuickUI was used in some companies for real production apps with real users. The very small number of developers who actually used the framework said they liked it and were impressed by what it could do.

  The bad side: As an open source project, QuickUI never achieved critical mass. QuickUI was my first attempt at kickstarting an open source project to help establish an ecosystem for component-based web user interfaces. I’d initially held the naive view that simply publishing something as open source (which I did in late 2009, two years into QuickUI’s development) would, on its own, generate community interest and participation. But the universe of open source development projects is vast, and simply making something free doesn’t make it popular. Free products still need to appeal to their audience and gain adoption through a good feature set, great distribution, and substantial luck.

  Eventually, QuickUI was overtaken by open web component standards (which is a good thing), and it no longer made sense to continue investment in QuickUI. Before moving on, I wanted to write down some of the lessons the QuickUI project held for me.

  <ol>
      <li><p><strong>People care about the stack of technologies beneath your project.</strong> I used to think that all that mattered is whether a tool worked and was easy to use, but most developers make demands the construction of the tool itself: programming language, runtime platform, dependent libraries, etc. The most common reason someone will offer for this is that they may need to diagnose a bug in the code and fix it. That may also be true, but I think most people have less glorified reasons for considering the technology behind a tool.</p>
  <p>
  First, simply understanding the vocabulary associated with a given stack requires investment. Occasionally you come across a tool on GitHub whose Readme says the tool can be configured via a .foo file, where the location and syntax of a .foo file is completely obvious to current users of that tool’s stack. If you don’t already know what a .foo file is, you’re less likely to adopt that tool.
  </p>
  <p>
  Second, a developer toolchain is a creaky, cantankerous beast, and incorporating multiple stacks of tech is a pain. This is less about debugging than what Bruce Sterling refers to as the <em>wrangling</em> required to get things to work together.
  </p>
  <p>
  Third, you trust tools on stacks that have worked for you in the past, and are skeptical that tools on unfamiliar stacks will actually work as advertised. For example, I’ve hardly ever used Ruby, and rarely use Ruby gems. When I see a tool published via npm, I feel comfortable installing and using it, even if I never look at its source, because I’ve used many tools that way. If I see a tool that does <em>the exact same thing</em> published as a Ruby gem, I view its efficacy as black magic.
  </p>
  <p>
  Last, people implicitly trust other people who have selected the same technology stack. “If someone has made the same technology choices I have, they must be as enlightened as I am!” Conversely, people look askance at those who make different choices. A die-hard plain JavaScript coder may view the Clojure community are pot-smoking hippies, while the Clojure developer may view the original party as a latter-day COBOL dork lacking sufficient brainpower and awareness.
  </p>
  <p>
  In the case of QuickUI, when I started on it in late 2007 or so, I was most comfortable writing in C#, so when I needed to write a build-time compiler for UI markup, I wrote it in C#. Bad idea. Despite the fact that there was no run-time need for .NET, and that the compiler ran perfectly well on a Mac (under Mono), no one would take it seriously with the taint of .NET on it. I was eventually able drop the compiler altogether, and rely on a stack of tools which jQuery developers were already familiar, but that cost the project time and effort.
  </p></li>
      <li><p><strong>Using anything other than native web technologies — plain HTML, plain JavaScript, and plain CSS — significantly constrains your audience.</strong> This is similar to the above point, but pertains to your project’s source code rather than the stack of technologies supporting that source. Again, part of the argument here is that they might theoretically need to dive into the runtime source to diagnose a problem, but I think the reaction is usually more instinctive than that.
  </p>
  <p>
  At one point in the development of QuickUI I discovered that working in CoffeeScript was much more productive for me than in plain JavaScript. In short order, I <a href="http://blog.quickui.org/2012/05/15/porting-quickui-to-coffeescript/">ported the QuickUI runtime to CoffeeScript</a>. Switching to CoffeeScript was a huge productivity boost for me — but represented a huge reduction on the potential audience for QuickUI.
  </p>
  <p>
  For one thing, it seemed nearly impossible for me to get potential developers to ignore the presence of CoffeeScript. CoffeeScript compiles to plain JavaScript, but anyone who looked at the QuickUI source repo saw “CoffeeScript” listed as the primary language… and walked away. They might say, “Your project looks interesting, but I don’t know CoffeeScript.” I’d tell them they didn’t need to know CoffeeScript — that was an implementation detail — but they’d already decided they were uninterested.
  </p>
  <p>
  Over and over, the general feeling was, “I just don’t want to use something that uses something I don’t already know.” And then, of course, for most people who really did want to be able to grok the source, CoffeeScript was a non-starter.
  </p>
  <p>
  To build a community around a project, you probably want as many people as possible to be able to participate. Even if you hate JavaScript, it’s the web’s lingua franca. Using any other language for an open web project may not be an insurmountable obstacle, but at the very least it’s a significant handicap. As much as it pained me, when I started up the subsequent <a href="http://janmiksovsky.github.io/quetzal/">Quetzal web components</a> experiments, I did so in plain JavaScript.
  </p></li>
      <li><p><strong>Everyone will insist there is one thing you must do that will make your library more acceptable — and all those things are different, and all those things together are probably still insufficient.</strong> Over the course of the past few years, I have given many, many QuickUI demos, and received feedback on all aspects of the tool, the accompanying site at quickui.org, the learning process, etc. Very little of this feedback was consistent; everyone fixated on something different. I thought, if I just respond to all the feedback, surely at some point the barrier to adoption will be low enough that people will start adopting the tool.
  </p>
  <p>
  On the basis of such feedback, I spent a huge amount of time improving things. Early on, someone said I should move the source to GitHub, so I did. Someone said it needed better documentation, so I wrote a lot of documentation. As discussed above, numerous people suggested moving away from .NET, so I did. Someone suggested having live examples of UI components, so I built those. Someone thought a tutorial would be helpful, so I made an interactive tutorial. (Which many people complimented. Thank you!) One person’s key complaint with the entire framework was that the home page didn’t have icons; if the framework was to be successful, the home page needed little icons to indicate which browsers were supported by the framework. I did that. I received many, many other suggestions, and I incorporated almost all of them.
  </p>
  <p>
  None of it mattered. The feedback was actionable, and probably much of it was accurate, but even addressing (nearly) all of it wasn’t enough to make the project successful.
  </p>
  <p>
  The fact is that most people are unwilling to invest the time to understand, analyze, and articulate what’s really wrong with your project. Of the people who gave me feedback, few of them actually looked hard at it, very few had actually tried it beyond the online tutorial, and very, very few were willing to speak directly to their key concerns. This is all understandable — people are busy, spending time on a framework of unknown value is potentially wasted, and most people want to be nice to you — but feedback on a project should be accepted with these phenomena in mind.</p></li>
      <li><p><strong>Paradigm shift is prohibitively expensive.</strong> Early on, one person told me that building UI in a component-oriented fashion represented a significant paradigm shift — and that represented a potentially insurmountable obstacle for QuickUI.
  </p>
  <p>
  The problem with a paradigm shift is that it’s hard to even have a conversation with someone whose conceptualization of the world doesn’t even allow them to recognize the problem they have. I spoke with many developers who viewed the undifferentiated pile of JavaScript generating their UI as the way things had to be done. They were more concerned with getting their UI to work across multiple browsers than to worry about componentization — even though a good component library is exactly the sort of thing that would have made cross-browser work more manageable. (The cross-browser hacks could have been folded into the components, allowing them to work at a higher level of abstraction, etc.) Interestingly, these same developers would carefully factor their code into classes or functions with clear lines of responsibility. They applied good factoring to every other thing they coded <em>except their web UI</em>.
  </p>
  <p>
  Over the past year or so, Google and others have been evangelizing a component-oriented paradigm for web development. At some point, we’ll go through some phase-change where that paradigm will suddenly become dominant. I’m betting that change will happen before late 2015. By then, it will be hard to find a good web UI developer who doesn't think of their UI in terms of components.</p></li>
      <li><p><strong>People are only interested in something if others are already using it.</strong> This is true for both seasoned developers and novice developers — but for different reasons. The novice teaches themself jQuery or Backbone or LESS because experienced people use those things, which means they’re probably interesting and useful. The seasoned developer picks up a new tool that others are using because the alternative — using something with a tiny user base — represents unacceptable risk.
  </p>
  <p>
  This last point was made to me by the most abrasive person I ever spoke with about QuickUI. In fact, I think it’s because they were untroubled by politeness that they could speak the truth. They said: “I would love to use this, but I can’t. If something were to happen to you, I would be stuck having to fix your bugs. I made a bet like this in the past, and was stuck supporting someone else’s framework. I won’t do that again. Come back when lots of other people are using this.”
  </p>
  <p>
  So this developer had, at some point, found a great piece of technology, developed by someone else, and they staked their own reputation on adopting this technology, only to have it completely fall apart when the other party went away (went bankrupt, was acquired, whatever). It’s probably safe to assume that most seasoned developers have had a similar experience. For every open library, there must exist some critical mass at which the library’s community becomes self-sustaining.
  </p>
  <p>
  At that point, if you find a bug in the library, someone else in the community has probably also found the bug, and maybe even fixed it. Enough other people are invested in the library that, even if the original developer disappears, the remaining investors will keep it going for as long as that makes technological sense.
  </p>
  <p>
  I’d be very interested if someone could pinpoint the size of that critical mass. I’m guessing the number is pretty small: perhaps 10 active contributors might be sufficient to create the perception the library is well-maintained and not going away. Whatever that size is, I couldn’t grow QuickUI to that size.</p></li>
      <li><p><strong>Google could publish a JavaScript library for cloud-based ham sandwiches and a thousand people would immediately star the repo on GitHub.</strong> For much of my career, I focused my attention almost entirely on the value a product created, and gave very little thought to how a product would be distributed. Distribution is, in fact, at least as important, and maybe more important, than underlying value. That’s certainly true in the short term. And, over the long term, well, maybe technology changes quickly enough that the long term never comes into play.
  </p>
  <p>
  I’m not saying individuals can’t launch successful open source projects, but rather that doing so within the context of a company with name recognition and a developer outreach program makes it much, much easier. The people working within such a context may not realize it. I once heard someone describe people who work at big companies as “basketball players on the moon”. Those people can jump very high, but they may not realize the extent to which their performance depends on that context.
  </p>
  <p>
  I have deep respect for a person who can launch something entirely on their own, without relying on the backing of their company (or industry name recognition predicated on work they launched previously at some earlier company). If someone can make a disruptive technology successful entirely on its own merits, both that tech and that person are impressive indeed.</p></li>
  </ol>

  Ah, well, live and learn. I’m still looking forward to watching the web’s UI component ecosystem take shape, because we’ll all get to make awesome stuff together.
